# German language file for GNU Bash 4.3
# Copyright (C) 2011 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Nils Naumann <nau@gmx.net>, 1996-2013.
msgid ""
msgstr ""
"Project-Id-Version: bash 4.3-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-11 11:19-0500\n"
"PO-Revision-Date: 2014-02-02 18:23+0100\n"
"Last-Translator: Nils Naumann <nau@gmx.net>\n"
"Language-Team: German <translation-team-de@lists.sourceforge.net>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8-bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: arrayfunc.c:51
msgid "bad array subscript"
msgstr "Falscher Feldbezeichner."

#: arrayfunc.c:356 builtins/declare.def:566
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: Kann nicht das indizierte in ein assoziatives Array umwandeln."

#: arrayfunc.c:539
#, c-format
msgid "%s: invalid associative array key"
msgstr "%s: Ungültiger Schlüssel für das assoziative Array."

#: arrayfunc.c:541
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: Kann nicht auf einen nicht-numerischen Index zuweisen."

#: arrayfunc.c:586
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr ""
"%s: %s: Ein Feldbezeicher wird zum Zuweisen eines assoziativen Arrays "
"benötigt."

#: bashhist.c:388
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: Kann die Datei %s nicht erzeugen."

#: bashline.c:3982
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"bash_execute_unix_command: Kann nicht die Tastenzuordnung für das Kommando "
"finden."

#: bashline.c:4069
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr " %s: Das erste Zeichen ist nicht `\\'."

#: bashline.c:4098
#, c-format
msgid "no closing `%c' in %s"
msgstr "fehlende schließende `%c' in %s."

#: bashline.c:4132
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: Fehlender Doppelpunkt."

#: braces.c:321
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr ""

#: braces.c:413
#, c-format
msgid "brace expansion: failed to allocate memory for %d elements"
msgstr ""

#: braces.c:452
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr ""

#: builtins/alias.def:132
#, c-format
msgid "`%s': invalid alias name"
msgstr "`%s': Ungültiger Alias Name."

#: builtins/bind.def:123 builtins/bind.def:126
msgid "line editing not enabled"
msgstr "Zeileneditierung ist nicht aktiviert."

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': Ungültiger KEYMAP Name."

#: builtins/bind.def:251
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: Nicht lesbar: %s"

#: builtins/bind.def:266
#, c-format
msgid "`%s': cannot unbind"
msgstr "`%s': Bindung kann nicht gelöst werden."

#: builtins/bind.def:304 builtins/bind.def:334
#, c-format
msgid "`%s': unknown function name"
msgstr "%s: Unbekannter Funktionsname."

#: builtins/bind.def:312
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s ist keiner Taste zugeordnet.\n"

#: builtins/bind.def:316
#, c-format
msgid "%s can be invoked via "
msgstr "%s kann aufgerufen werden durch "

#: builtins/break.def:77 builtins/break.def:117
msgid "loop count"
msgstr "Schleifen Zähler"

#: builtins/break.def:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "nur in einer `for', `while' oder `until' Schleife sinnvoll."

# Problem mit Extraktion des Strings
#: builtins/caller.def:134
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr ""

#: builtins/cd.def:319
msgid "HOME not set"
msgstr "HOME ist nicht zugewiesen."

#: builtins/cd.def:327 builtins/common.c:166 test.c:876
msgid "too many arguments"
msgstr "Zu viele Argumente."

#: builtins/cd.def:338
msgid "OLDPWD not set"
msgstr "OLDPWD ist nicht zugewiesen."

# Debug Ausgabe
#: builtins/common.c:101
#, c-format
msgid "line %d: "
msgstr "Zeile %d: "

#: builtins/common.c:139 error.c:265
#, c-format
msgid "warning: "
msgstr "Warnung: "

#: builtins/common.c:153
#, c-format
msgid "%s: usage: "
msgstr "%s: Gebrauch: "

#: builtins/common.c:191 shell.c:506 shell.c:788
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: Ein numerischer Paremeter ist erforderlich."

#: builtins/common.c:198
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: Ein numerischer Parameter ist erforderlich."

#: builtins/common.c:205
#, c-format
msgid "%s: not found"
msgstr "%s: Nicht gefunden."

#: builtins/common.c:214 shell.c:801
#, c-format
msgid "%s: invalid option"
msgstr "%s: Ungültige Option"

#: builtins/common.c:221
#, c-format
msgid "%s: invalid option name"
msgstr "%s: Ungültiger Optionsname."

#: builtins/common.c:228 general.c:235 general.c:240
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': Ist kein gültiger Bezeichner."

#: builtins/common.c:238
msgid "invalid octal number"
msgstr "Ungültige Oktalzahl."

#: builtins/common.c:240
msgid "invalid hex number"
msgstr "Ungültige hexadezimale Zahl."

#: builtins/common.c:242 expr.c:1470
msgid "invalid number"
msgstr "Ungültige Zahl."

#: builtins/common.c:250
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: Ungültige Signalbezeichnung."

#: builtins/common.c:257
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': Ist keine gültige Prozess- oder Jobbezeichnung."

#: builtins/common.c:264 error.c:488
#, c-format
msgid "%s: readonly variable"
msgstr "%s: Schreibgeschützte Variable."

#: builtins/common.c:272
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:272 builtins/common.c:274
msgid "argument"
msgstr "Argument"

#: builtins/common.c:274
#, c-format
msgid "%s out of range"
msgstr "%s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:282
#, c-format
msgid "%s: no such job"
msgstr "%s: Kein solcher Job."

#: builtins/common.c:290
#, c-format
msgid "%s: no job control"
msgstr "%s: Keine Job Steuerung in dieser Shell."

#: builtins/common.c:292
msgid "no job control"
msgstr "Keine Job Steuerung in dieser Shell."

#: builtins/common.c:302
#, c-format
msgid "%s: restricted"
msgstr "%s: gesperrt"

#: builtins/common.c:304
msgid "restricted"
msgstr "gesperrt"

#: builtins/common.c:312
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: Ist kein Shell Kommando."

#: builtins/common.c:321
#, c-format
msgid "write error: %s"
msgstr "Schreibfehler: %s."

#: builtins/common.c:329
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "Fehler beim Setzen der Terminalattribute: %s"

#: builtins/common.c:331
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "Fehler beim Ermitteln der Terminalattribute: %s"

#: builtins/common.c:563
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: Kann das aktuelle Verzeichnis nicht wiederfinden: %s: %s\n"

#: builtins/common.c:629 builtins/common.c:631
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Mehrdeutige Job Bezeichnung."

#: builtins/complete.def:277
#, c-format
msgid "%s: invalid action name"
msgstr "%s: Ungültige Methode."

#: builtins/complete.def:450 builtins/complete.def:645
#: builtins/complete.def:855
#, c-format
msgid "%s: no completion specification"
msgstr "%s: Keine Komplettierung angegeben."

#: builtins/complete.def:697
msgid "warning: -F option may not work as you expect"
msgstr "Warnung: Die -F Option könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:699
msgid "warning: -C option may not work as you expect"
msgstr "Warnung: Die -C Option könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:828
msgid "not currently executing completion function"
msgstr "Gegenwärtig wird keine Komplettierungsfunktion ausgeführt."

#: builtins/declare.def:126
msgid "can only be used in a function"
msgstr "kann nur innerhalb einer Funktion benutzt werden."

#: builtins/declare.def:315 builtins/declare.def:509
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr ""

#: builtins/declare.def:324
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr ""

#: builtins/declare.def:398
msgid "cannot use `-f' to make functions"
msgstr "Mit `-f' können keine Funktionen erzeugt werden."

#: builtins/declare.def:410 execute_cmd.c:5361
#, c-format
msgid "%s: readonly function"
msgstr "%s: Schreibgeschützte Funktion."

#: builtins/declare.def:553
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: Kann Feldvariablen nicht auf diese Art löschen."

#: builtins/declare.def:560 builtins/read.def:733
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr ""
"%s: Konvertieren von assoziativen in indizierte Arrays ist nicht möglich."

#: builtins/enable.def:137 builtins/enable.def:145
msgid "dynamic loading not available"
msgstr "Dynamisches Laden ist nicht verfügbar."

#: builtins/enable.def:312
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "Kann die dynamische Bibiliothek nicht laden %s: %s"

#: builtins/enable.def:335
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "Kann %s nicht in der dynamischen Bibiliothek finden %s: %s"

#: builtins/enable.def:459
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: Ist nicht dynamisch geladen."

#: builtins/enable.def:474
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: Kann nicht löschen: %s"

#: builtins/evalfile.c:140 builtins/hash.def:171 execute_cmd.c:5208
#: shell.c:1481
#, c-format
msgid "%s: is a directory"
msgstr "%s: ist ein Verzeichnis."

#: builtins/evalfile.c:146
#, c-format
msgid "%s: not a regular file"
msgstr "%s: Ist keine normale Datei."

#: builtins/evalfile.c:155
#, c-format
msgid "%s: file is too large"
msgstr "%s: Die Datei ist zu groß."

#: builtins/evalfile.c:190 builtins/evalfile.c:208 shell.c:1491
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: Kann die Datei nicht ausführen."

#: builtins/exec.def:154 builtins/exec.def:156 builtins/exec.def:228
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: Kann nicht ausführen: %s"

#: builtins/exit.def:65
#, c-format
msgid "logout\n"
msgstr "Abgemeldet\n"

#: builtins/exit.def:88
msgid "not login shell: use `exit'"
msgstr "Keine Login Shell: Mit `exit' abmelden!"

#: builtins/exit.def:120
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Es gibt noch angehaltene Prozesse.\n"

#: builtins/exit.def:122
#, c-format
msgid "There are running jobs.\n"
msgstr "Es gibt noch laufende Prozesse.\n"

#: builtins/fc.def:262
msgid "no command found"
msgstr "Kein Kommando gefunden."

#: builtins/fc.def:320 builtins/fc.def:369
msgid "history specification"
msgstr ""

#: builtins/fc.def:390
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: Kann die tempräre Datei nicht öffnen: %s"

#: builtins/fg_bg.def:149 builtins/jobs.def:282
msgid "current"
msgstr "gegenwärtig"

#: builtins/fg_bg.def:158
#, c-format
msgid "job %d started without job control"
msgstr "Job %d wurde ohne Jobsteuerung gestartet."

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: Ungültige Option -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: Diese Option erfordert ein Argument -- %c\n"

#: builtins/hash.def:92
msgid "hashing disabled"
msgstr "Hashing deaktiviert."

#: builtins/hash.def:138
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: Die Hashtabelle ist leer.\n"

#: builtins/hash.def:245
#, c-format
msgid "hits\tcommand\n"
msgstr "Treffer\tBefehl\n"

#: builtins/help.def:130
#, c-format
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Shell Kommandos auf die das Schlüsselwort zutrifft `"
msgstr[1] "Shell Kommandos auf die die Schlüsselwörter zutreffen `"

#: builtins/help.def:182
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"Auf `%s' trifft kein Hilfethema zu.  Probieren Sie `help help', `man -k %s' "
"oder `info %s'."

#: builtins/help.def:199
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: Kann die Datei nicht öffnen: %s"

#: builtins/help.def:485
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Die Shell Kommandos sind intern definiert.  Mit `help' kann eine Liste\n"
"angesehen werden.  Durch `help Name' wird eine Beschreibung der\n"
"Funktion `Name' angezeigt.  Die Dokumentation ist mit `info bash'\n"
"einsehbar.  Detaillierte Beschreibungen der Shellkommandos sind mit\n"
"`man -k' oder `info' abrufbar.\n"
"\n"
"Ein Stern (*) neben dem Namen kennzeichnet deaktivierte Kommandos.\n"
"\n"

#: builtins/history.def:154
msgid "cannot use more than one of -anrw"
msgstr "Es darf nur eine Option aus -anrw angegeben werden."

#: builtins/history.def:186
msgid "history position"
msgstr "Kommandostapelposition."

#: builtins/history.def:366
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: Kommandoersetzung gescheitert."

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib gescheitert."

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "Keine weiteren Optionen mit `-x' erlaubt."

#: builtins/kill.def:200
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: Die Argumente müssen Prozess- oder Jobbezeichnungen sein."

#: builtins/kill.def:263
msgid "Unknown error"
msgstr "Unbekannter Fehler."

#: builtins/let.def:95 builtins/let.def:120 expr.c:583 expr.c:598
msgid "expression expected"
msgstr "Ausdruck erwartet."

#: builtins/mapfile.def:172
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: Ist kein indiziertes Array."

#: builtins/mapfile.def:259 builtins/read.def:302
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: Ungültige Datei-Deskriptor Angabe."

#: builtins/mapfile.def:267 builtins/read.def:309
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: Ungültiger Datei-Deskriptor: %s"

#: builtins/mapfile.def:276 builtins/mapfile.def:314
#, c-format
msgid "%s: invalid line count"
msgstr "%s: Ungültige Zeilenanzahlangabe."

#: builtins/mapfile.def:287
#, c-format
msgid "%s: invalid array origin"
msgstr "%s:  Ungültiger Zeilenindex für den Array Beginn."

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid callback quantum"
msgstr ""

#: builtins/mapfile.def:336
msgid "empty array variable name"
msgstr "Fehlender Name für die Array Variable."

#: builtins/mapfile.def:357
msgid "array variable support required"
msgstr "Die Array Variablen Unterstützung ist in dieser Shell nicht vorhanden."

#: builtins/printf.def:402
#, c-format
msgid "`%s': missing format character"
msgstr "`%s': Fehlendes Formatierungszeichen."

#: builtins/printf.def:456
#, c-format
msgid "`%c': invalid time format specification"
msgstr "`%c': Ungültige Zeitformatangabe."

#: builtins/printf.def:658
#, c-format
msgid "`%c': invalid format character"
msgstr "`%c': Ungültiges Formatierungszeichen."

#: builtins/printf.def:684
#, c-format
msgid "warning: %s: %s"
msgstr "Warnung: %s: %s"

#: builtins/printf.def:768
#, c-format
msgid "format parsing problem: %s"
msgstr ""

#: builtins/printf.def:865
msgid "missing hex digit for \\x"
msgstr "Fehlende hexadezimale Ziffer nach \\x."

#: builtins/printf.def:880
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "Fehlendes Unicode Zeichen für \\%c."

#: builtins/pushd.def:195
msgid "no other directory"
msgstr "kein anderes Verzeichnis"

#: builtins/pushd.def:354
#, c-format
msgid "%s: invalid argument"
msgstr "%s: Ungültiges Argument."

#: builtins/pushd.def:468
msgid "<no current directory>"
msgstr "<kein aktuelles Verzeichnis>"

#: builtins/pushd.def:512
msgid "directory stack empty"
msgstr "Der Verzeichnisstapel ist leer."

#: builtins/pushd.def:514
msgid "directory stack index"
msgstr "Verzeichnisstapelindex"

#: builtins/pushd.def:689
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse an.  Durch\n"
"    das »pushd« Kommando werden die Verzeichnisse auf den Stapel gelegt\n"
"    und können durch das »popd« Kommando wieder vom Stapel entfernt\n"
"    werden.\n"
"\n"
"    Optionen:\n"
"\t-c\tVerzeichnisstapel durch Löschen aller Einträge bereinigen.\n"
"\t-l\tDas Heimatverzeichnis wird nicht mit vorangestellter Tilde\n"
"\tausgegeben\n"
"\t-p\tDen Verzeichnisstapel zeilenweise ausgeben.\n"
"\t-v\tDen Verzeichnisstapel zeilenweise mit vorangestellter\n"
"\tPositionsnummer auseben.\n"
"\n"
"    Argumente:\n"
"\t+N\tZeigt den N'ten Eintrag von links an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null.\n"
"\t-N\tZeigt den N'ten Eintrag von rechts an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null."

#: builtins/pushd.def:711
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Legt ein Verzeichniseintrag auf den Verzeichnisstapel ab oder rotiert\n"
"den Stapel so, dass das aktuelle Verzeichnis oben liegt.  Ohne Argumente\n"
"werden die beiden oberen Einträge vertauscht.\n"
"\n"
"    Optionen: \n"
"       -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"\n"
"    Argumente:\n"
"      +N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon links, das von `dirs' angezeigt wird, nach oben kommt.  Die Zählung\n"
"\tbeginnt dabei mit Null.\n"
"\n"
"      -N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon rechts, das von `dirs' angezeigt wird, nach oben kommt.  Die \n"
"\tZählung beginnt dabei mit Null.\n"
"\n"
"      dir\tLegt DIR auf den Verzeichnisstapel und wechselt in dieses\n"
"      Verzeichnis.\n"
"    \n"
"    Das `dirs' Kommando zeigt den Verueichnisstapel an."

#: builtins/pushd.def:736
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Erntfernt Einträge vom Stapel.  Ohne Argumente wird der oberste Eintrag\n"
"    gelöscht und anschließend in das das neue oben liegede Verzeichnis\n"
"    gewechselt.\n"
"    \n"
"    Optionen:\n"
"      -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"    \n"
"    Argumente:\n"
"      +N\tEntfernt den N-ten Eintrag von links, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. `popd +0' den ersten und `popd +1' den zweiten\n"
"\tEintrag.\n"
"    \n"
"      -N\tEntfernt den N-ten Eintrag von rechts, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. `popd -0' den letzten und `popd +1' den vorletzten\n"
"\tEintrag.\n"
"    \n"
"    Das `dirs' Kommando zeigt den Verzeichnisstapel an."

#: builtins/read.def:275
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: Ungültige Wartezeitangebe."

#: builtins/read.def:678
#, c-format
msgid "read error: %d: %s"
msgstr "Lesefehler: %d: %s"

#: builtins/return.def:75
msgid "can only `return' from a function or sourced script"
msgstr ""
"»Return« ist nur aus einer Funktion oder einem mit »source« ausgefühten "
"Skript möglich."

#: builtins/set.def:782
msgid "cannot simultaneously unset a function and a variable"
msgstr ""
"Gleichzeitiges `unset' einer Funktion und einer Variable ist nicht möglich."

#: builtins/set.def:826
#, c-format
msgid "%s: cannot unset"
msgstr "%s: `unset' nicht möglich."

#: builtins/set.def:843
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: `unset' nicht möglich: Schreibgeschützt %s"

#: builtins/set.def:854
#, c-format
msgid "%s: not an array variable"
msgstr "%s: Ist keine Feldvariable."

#: builtins/setattr.def:187
#, c-format
msgid "%s: not a function"
msgstr "%s: Ist keine Funktion."

#: builtins/shift.def:71 builtins/shift.def:77
msgid "shift count"
msgstr "Verschiebezähler"

#: builtins/shopt.def:279
msgid "cannot set and unset shell options simultaneously"
msgstr "Kann nicht Shell Optinen gleichzeitig aktivieren und deaktivieren."

#: builtins/shopt.def:346
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: Ungültiger Shell Optionen Name."

#: builtins/source.def:130
msgid "filename argument required"
msgstr "Ein Dateiname wird as Argument benötigt."

#: builtins/source.def:155
#, c-format
msgid "%s: file not found"
msgstr "%s: Datei nicht gefunden."

#: builtins/suspend.def:101
msgid "cannot suspend"
msgstr "Kann die Shell nicht unterbrechen."

# logout
#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "Kann die Loginshell nicht unterbrechen."

#: builtins/type.def:234
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s ist ein Alias von `%s'.\n"

#: builtins/type.def:255
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s Ist ein reserviertes Schlüsselwort der Shell.\n"

#: builtins/type.def:274
#, c-format
msgid "%s is a function\n"
msgstr "%s ist eine Funktion.\n"

#: builtins/type.def:296
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s ist eine von der Shell mitgelieferte Funktion.\n"

#: builtins/type.def:317 builtins/type.def:393
#, c-format
msgid "%s is %s\n"
msgstr "%s ist %s\n"

#: builtins/type.def:337
#, c-format
msgid "%s is hashed (%s)\n"
msgstr ""

#: builtins/ulimit.def:383
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: Ungültiges Grenzwertargument."

#: builtins/ulimit.def:409
#, c-format
msgid "`%c': bad command"
msgstr "`%c': Falsches Kommando."

#: builtins/ulimit.def:438
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: Kann die nicht Grenze setzen: %s"

#: builtins/ulimit.def:464
msgid "limit"
msgstr "Grenze"

#: builtins/ulimit.def:476 builtins/ulimit.def:776
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: Kann die Grenze nicht ändern: %s"

#: builtins/umask.def:114
msgid "octal number"
msgstr "Oktalzahl"

#: builtins/umask.def:227
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': Ungültiger Operator für den symbolischen Modus."

#: builtins/umask.def:282
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': Ungültiges Zeichen im symbolischen Modus."

#: error.c:90 error.c:325 error.c:327 error.c:329
msgid " line "
msgstr " Zeile "

#: error.c:165
#, c-format
msgid "last command: %s\n"
msgstr "Letztes Kommando: %s\n"

#: error.c:173
#, c-format
msgid "Aborting..."
msgstr "Abbruch..."

#: error.c:440
msgid "unknown command error"
msgstr "Unbekanntes Kommando"

#: error.c:441
msgid "bad command type"
msgstr ""

# Programmierfehler
#: error.c:442
msgid "bad connector"
msgstr ""

#: error.c:443
msgid "bad jump"
msgstr "Falscher Sprung"

#: error.c:481
#, c-format
msgid "%s: unbound variable"
msgstr "%s ist nicht gesetzt."

#: eval.c:189
#, c-format
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aZu lange keine Eingabe: Automatisch ausgeloggt.\n"

#: execute_cmd.c:512
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "Kann nicht die Standardeingabe von /dev/null umleiten: %s"

#: execute_cmd.c:1233
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': Ungültiges Formatzeichen."

#: execute_cmd.c:2287
msgid "pipe error"
msgstr "Pipe-Fehler"

#: execute_cmd.c:4386
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr ""

#: execute_cmd.c:4884
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: Verboten:  `/' ist in Kommandonamen unzulässig."

#: execute_cmd.c:4973
#, c-format
msgid "%s: command not found"
msgstr "%s: Kommando nicht gefunden."

#: execute_cmd.c:5206
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5243
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: Defekter Interpreter"

#: execute_cmd.c:5280
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: Kann die Binärdatei nicht ausführen: %s"

#: execute_cmd.c:5352
#, c-format
msgid "`%s': is a special builtin"
msgstr "`%s' ist eine spezielle eingebaute Funktion."

#: execute_cmd.c:5404
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "Kann fd %d nicht auf fd %d verdoppeln."

#: expr.c:259
msgid "expression recursion level exceeded"
msgstr "Zu viele Rekursionen in Ausdruck."

#: expr.c:283
msgid "recursion stack underflow"
msgstr "Rekursionsstapel leer."

#: expr.c:431
msgid "syntax error in expression"
msgstr "Syntaxfehler im Ausdruck."

#: expr.c:475
msgid "attempted assignment to non-variable"
msgstr "Versuchte Zuweisung zu keiner Variablen."

#: expr.c:495 expr.c:858
msgid "division by 0"
msgstr "Division durch 0."

#: expr.c:542
msgid "bug: bad expassign token"
msgstr "Fehler: Falscher Zuweisungsoperator."

#: expr.c:595
msgid "`:' expected for conditional expression"
msgstr "`:' für ein bedingten Ausdruck erwaret."

#: expr.c:919
msgid "exponent less than 0"
msgstr "Der Exponent ist kleiner als 0."

#: expr.c:976
msgid "identifier expected after pre-increment or pre-decrement"
msgstr ""
"Nach einem Präinkrement oder Prädekrement wird ein Bezeichner erwartet."

#: expr.c:1002
msgid "missing `)'"
msgstr "Fehlende `)'"

#: expr.c:1053 expr.c:1390
msgid "syntax error: operand expected"
msgstr "Syntax Fehler: Operator erwartet."

#: expr.c:1392
msgid "syntax error: invalid arithmetic operator"
msgstr "Syntaxfehler: Ungültiger arithmetischer Operator."

#: expr.c:1416
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (Fehlerverursachendes Zeichen ist \\\"%s\\\")."

#: expr.c:1474
msgid "invalid arithmetic base"
msgstr "Ungültige Basis."

#: expr.c:1494
msgid "value too great for base"
msgstr "Der Wert ist für die aktuelle Basis zu groß."

#: expr.c:1543
#, c-format
msgid "%s: expression error\n"
msgstr "%s: Fehler im Ausdruck.\n"

#: general.c:62
msgid "getcwd: cannot access parent directories"
msgstr "getwd: Kann auf das übergeordnete Verzeichnis nicht zugreifen."

#: input.c:102 subst.c:5168
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "Konnte den No-Delay Modus für fd %d nicht wieder herstellen."

#: input.c:271
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "Kann keinen neuen Filedeskriptor für die Eingabe von fd %d zuweisen."

# Debug Ausgabe
#: input.c:279
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: Es existiert bereits ein Puffer für den neuen fd %d."

#: jobs.c:471
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:893
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "Die geforkte PID %d erscheint im laufenden Prozess %d."

#: jobs.c:1012
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "Lösche den gestoppten Prozess %d der Prozessgruppe %ld."

#: jobs.c:1117
#, c-format
msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr ""

#: jobs.c:1120
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr ""

# Programmierfehler
#: jobs.c:1435
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: Prozeßnummer existiert nicht."

#: jobs.c:1450
#, c-format
msgid "Signal %d"
msgstr "Signal %d"

#: jobs.c:1464 jobs.c:1489
msgid "Done"
msgstr "Fertig"

#: jobs.c:1469 siglist.c:123
msgid "Stopped"
msgstr "Angehalten"

#: jobs.c:1473
#, c-format
msgid "Stopped(%s)"
msgstr "Angehalten(%s)"

#: jobs.c:1477
msgid "Running"
msgstr "Läuft"

#: jobs.c:1491
#, c-format
msgid "Done(%d)"
msgstr "Fertig(%d)"

#: jobs.c:1493
#, c-format
msgid "Exit %d"
msgstr "Exit %d"

#: jobs.c:1496
msgid "Unknown status"
msgstr "Unbekannter Status"

#: jobs.c:1583
#, c-format
msgid "(core dumped) "
msgstr "(Speicherabzug geschrieben) "

#: jobs.c:1602
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd: %s)"

# interner Fehler
#: jobs.c:1819
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr ""

#: jobs.c:2138 nojobs.c:605
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: Prozeß %ld wurde nicht von dieser Shell gestartet."

#: jobs.c:2385
#, c-format
msgid "wait_for: No record of process %ld"
msgstr ""

#: jobs.c:2694
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr ""

#: jobs.c:2986
#, c-format
msgid "%s: job has terminated"
msgstr "%s: Programm ist beendet."

#: jobs.c:2995
#, c-format
msgid "%s: job %d already in background"
msgstr ""

#: jobs.c:3220
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""

# Debug Ausgabe
#: jobs.c:3711
#, c-format
msgid "%s: line %d: "
msgstr "%s: Zeile %d: "

#: jobs.c:3725 nojobs.c:843
#, c-format
msgid " (core dumped)"
msgstr " (Speicherabzug geschrieben)"

#: jobs.c:3737 jobs.c:3750
#, c-format
msgid "(wd now: %s)\n"
msgstr "(gegenwärtiges Arbeitsverzeichnis ist: %s)\n"

# interner Fehler
#: jobs.c:3782
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_jobs: getpgrp war nicht erfolgreich."

# interner Fehler
#: jobs.c:3843
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: line discipline"

# interner Fehler
#: jobs.c:3853
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:3874 jobs.c:3883
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "Kann die Prozessgruppe des Terminals nicht setzen (%d)."

#: jobs.c:3888
msgid "no job control in this shell"
msgstr "Keine Job Steuerung in dieser Shell."

#: lib/malloc/malloc.c:296
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: Speicherzusicherung gescheitert: %s.\n"

#: lib/malloc/malloc.c:312
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\\r\n"
"malloc: %s:%d: Speicherzusicherung verpfuscht\\r\n"

#: lib/malloc/malloc.c:313
msgid "unknown"
msgstr "Unbekannt"

#: lib/malloc/malloc.c:801
msgid "malloc: block on free list clobbered"
msgstr ""
"Malloc:  Ein frei gekennzeichneter Speicherbereich wurde überschrieben."

#: lib/malloc/malloc.c:878
msgid "free: called with already freed block argument"
msgstr "free:  Wurde für bereits freigegebenen Speicherbereich aufgerufen."

#: lib/malloc/malloc.c:881
msgid "free: called with unallocated block argument"
msgstr "free: Wurde für nicht zugeordneten Speicherbereich aufgerufen."

#: lib/malloc/malloc.c:900
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#: lib/malloc/malloc.c:906
msgid "free: start and end chunk sizes differ"
msgstr "free: Beginn und Ende Segmentgrößen sind unterschiedlich."

#: lib/malloc/malloc.c:1005
msgid "realloc: called with unallocated block argument"
msgstr "realloc: Mit nicht zugewiesenen Argument aufgerufen."

#: lib/malloc/malloc.c:1020
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""
"realloc: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#: lib/malloc/malloc.c:1026
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: Beginn und Ende Segmentgrößen sind unterschiedlich.<"

#: lib/malloc/table.c:194
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr ""
"register_alloc: Speicherzuordnungstabelle ist mit FIND_ALLOC gefüllt?\n"

#: lib/malloc/table.c:203
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr ""
"register_alloc: %p ist bereits in der Speicherzuordnungstabelle als belegt "
"gekennzeichnet?\n"

#: lib/malloc/table.c:256
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr ""
"register_free: %p ist bereits in der Speicherzuordnungstabelle als frei "
"gekennzeichnet?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "Ungültige Basis"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: Unbekannter Host."

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: unbekannter Dienst."

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: Fehlerhafte Netzwerkspfadangabe."

#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr "Der Netzwerkbetrieb ist nicht unterstützt."

#: locale.c:200
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: Kann die Locale nicht ändern (%s)."

#: locale.c:202
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: Kann die Locale nicht ändern (%s): %s"

#: locale.c:259
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: Kann die Standorteinstellungen nicht ändern (%s)."

#: locale.c:261
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: Kann nicht die Locale ändern (%s): %s"

# Du oder Sie?
#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Sie haben Post in $_."

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Sie haben neue Post in $_."

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Die Post in %s wurde bereits gelesen.\n"

#: make_cmd.c:323
msgid "syntax error: arithmetic expression required"
msgstr "Syntaxfehler: Es wird ein arithmetischer Ausdruck benötigt."

#: make_cmd.c:325
msgid "syntax error: `;' unexpected"
msgstr "Syntax Fehler: unerwartetes `;'."

#: make_cmd.c:326
#, c-format
msgid "syntax error: `((%s))'"
msgstr "Syntax Fehler: `((%s))'."

# interner Fehler
#: make_cmd.c:578
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: Falscher Befehlstyp %d."

#: make_cmd.c:662
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"Das in der Zeile %d beginnende Here-Dokument geht bis zum Dateiende "
"(erwartet wird `%s')."

#: make_cmd.c:759
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""

#: parse.y:3278 parse.y:3561
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "Dateiende beim Suchen nach `%c' erreicht."

#: parse.y:4170
msgid "unexpected EOF while looking for `]]'"
msgstr "Dateiende beim Suchen nach `]]' erreicht."

#: parse.y:4175
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "Syntaxfehler im bedingten Ausdruck: Unerwartetes Zeichen `%s'."

#: parse.y:4179
msgid "syntax error in conditional expression"
msgstr "Syntaxfehler im bedingen Ausdruck."

#: parse.y:4257
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "Unerwartetes Zeichen: `%s' anstatt von `)'"

#: parse.y:4261
msgid "expected `)'"
msgstr "`)' erwartet."

#: parse.y:4289
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr ""

#: parse.y:4293
msgid "unexpected argument to conditional unary operator"
msgstr ""

#: parse.y:4339
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr ""

#: parse.y:4343
msgid "conditional binary operator expected"
msgstr ""

#: parse.y:4365
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr ""

#: parse.y:4369
msgid "unexpected argument to conditional binary operator"
msgstr ""

#: parse.y:4380
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr ""

#: parse.y:4383
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr ""

#: parse.y:4387
#, c-format
msgid "unexpected token %d in conditional command"
msgstr ""

#: parse.y:5737
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "Syntaxfehler beim unerwarteten Wort `%s'"

#: parse.y:5755
#, c-format
msgid "syntax error near `%s'"
msgstr "Syntaxfehler beim unerwarteten Wort `%s'"

#: parse.y:5765
msgid "syntax error: unexpected end of file"
msgstr "Syntax Fehler: Unerwartetes Dateiende."

#: parse.y:5765
msgid "syntax error"
msgstr "Syntax Fehler"

# Du oder Sie?
#: parse.y:5827
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Benutze \"%s\" um die Shell zu verlassen.\n"

#: parse.y:5989
msgid "unexpected EOF while looking for matching `)'"
msgstr "Dateiende beim Suchen nach passender `)' erreicht."

#: pcomplete.c:1094
#, c-format
msgid "completion: function `%s' not found"
msgstr ""

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr ""

#: print_cmd.c:300
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: Falsches Verbindungszeichen `%d'."

#: print_cmd.c:373
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: Ungültige Dateibeschreibung."

#: print_cmd.c:378
msgid "xtrace_set: NULL file pointer"
msgstr ""

#: print_cmd.c:382
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr ""

#: print_cmd.c:1518
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr ""

#: redir.c:123 redir.c:170
msgid "file descriptor out of range"
msgstr ""

#: redir.c:177
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: Mehrdeutige Umlenkung."

#: redir.c:181
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: Kann existierende Datei nicht überschreiben."

#: redir.c:186
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: Gesperrt: Die Ausgabe darf nicht umgeleitet werden."

#: redir.c:191
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr ""

#: redir.c:195
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: Kann fd keiner Variable zuweisen."

#: redir.c:582
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port Wird ohne Netzwerk nicht unterstützt"

#: redir.c:861 redir.c:973 redir.c:1034 redir.c:1199
msgid "redirection error: cannot duplicate fd"
msgstr ""

#: shell.c:339
msgid "could not find /tmp, please create!"
msgstr "Konnte das /tmp Verzeichnis nicht finden, bitte anlegen."

#: shell.c:343
msgid "/tmp must be a valid directory name"
msgstr "/tmp muß ein gültiger Verzeichnisname sein."

#: shell.c:890
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: Ungültige Option"

#: shell.c:1682
msgid "I have no name!"
msgstr "Ich habe keinen Benutzernamen!"

#: shell.c:1827
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, Version %s-(%s)\n"

#: shell.c:1828
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Benutzung:\t%s [Lange GNU Option] [Option] ...\n"
"\t\t%s [Lange GNU Option] [Option] Script-Datei ...\n"

#: shell.c:1830
msgid "GNU long options:\n"
msgstr "Lange GNU Optionen:\n"

#: shell.c:1834
msgid "Shell options:\n"
msgstr "Shell-Optionen:\n"

#: shell.c:1835
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr ""
"\t-ilrsD oder -c Kommando\toder -O shopt_option            (Nur Aufruf)\n"

#: shell.c:1850
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s oder Option -o\n"

#: shell.c:1856
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "`%s -c \"help set\"' für mehr Informationen über Shell-Optionen.\n"

#: shell.c:1857
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "`%s -c help' für mehr Information über Shell-Kommandos.\n"

#: shell.c:1858
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Mit dem `bashbug' Kommando können Fehler gemeldet werden.\n"

#: sig.c:691
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: Ungültige Operation"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Falsches Signal."

#: siglist.c:51
msgid "Hangup"
msgstr "Aufgelegt"

#: siglist.c:55
msgid "Interrupt"
msgstr "Unterbrochen (Interrupt)"

#: siglist.c:59
msgid "Quit"
msgstr "Quit"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Ungültige Anweisung."

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Verfolgen/anhalten abfangen (Trace/breakpoint trap)"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Abbruchkommando"

#: siglist.c:79
msgid "EMT instruction"
msgstr "EMT abfangen (EMT trap)"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Gleitkommafehler"

#: siglist.c:87
msgid "Killed"
msgstr "Abgebrochen (Killed)"

#: siglist.c:91
msgid "Bus error"
msgstr "Bus-Fehler"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Adressierungsfehler"

#: siglist.c:99
msgid "Bad system call"
msgstr "Falscher Systemaufruf"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Unterbrochene Pipe"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Wecker"

#: siglist.c:111
msgid "Terminated"
msgstr "Abgebrochen (Terminated)"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Dringende IO-Bedingung"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Angehalten (Signal)"

#: siglist.c:127
msgid "Continue"
msgstr "Prozeßbearbeitung wieder aufgenommen."

#: siglist.c:135
msgid "Child death or stop"
msgstr "Kindprozeß abgebrochen oder gestoppt."

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Angehalten (Terminaleingabe)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Angehalten (Terminalausgabe)"

#: siglist.c:147
msgid "I/O ready"
msgstr "E/A fertig"

#: siglist.c:151
msgid "CPU limit"
msgstr "Rechenzeitgrenze"

#: siglist.c:155
msgid "File limit"
msgstr "Grenze für Dateigröße"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarm (Virtuell)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarm (Profil)"

#: siglist.c:167
msgid "Window changed"
msgstr "Fenster geändert."

#: siglist.c:171
msgid "Record lock"
msgstr "Datei blockiert."

#: siglist.c:175
msgid "User signal 1"
msgstr "Nutzersignal 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Nutzersignal 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "HFT Eingabedaten ausstehend."

#: siglist.c:187
msgid "power failure imminent"
msgstr "Spannungsausfall steht bevor."

#: siglist.c:191
msgid "system crash imminent"
msgstr "Systemausfall steht bevor."

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "Verlege den Prozeß auf einen anderen Prozessor."

#: siglist.c:199
msgid "programming error"
msgstr "Programmierfehler"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "HFT-Monitormodus erlaubt."

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "HFT-Monitormodus abgeschaltet."

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFT-Tonfolge beendet."

#: siglist.c:215
msgid "Information request"
msgstr "Informationsanforderung"

#: siglist.c:223
msgid "Unknown Signal #"
msgstr "Unbekannte Signalnummer."

#: siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Unbekanntes Signal Nr.: %d."

#: subst.c:1362 subst.c:1520
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Falsche Ersetzung: Keine schließende `%s' in `%s' enthalten."

#: subst.c:2847
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: Kann einem Feldelement keine Liste zuweisen."

#: subst.c:5065 subst.c:5081
msgid "cannot make pipe for process substitution"
msgstr "Kann keine Pipe für die Prozeßersetzung erzeugen."

#: subst.c:5113
msgid "cannot make child for process substitution"
msgstr "Kann den Kindsprozess für die Prozeßersetzung nicht erzeugen."

#: subst.c:5158
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "Kann nicht die benannte Pipe %s zum lesen öffnen."

#: subst.c:5160
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "Kann nicht die benannte Pipe %s zum schreiben öffnen."

#: subst.c:5178
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "Kann die benannte Pipe %s nicht auf fd %d."

#: subst.c:5376
msgid "cannot make pipe for command substitution"
msgstr "Kann keine Pipes für Kommandoersetzung erzeugen."

#: subst.c:5414
msgid "cannot make child for command substitution"
msgstr "Kann keinen Unterprozess für die Kommandoersetzung erzeugen."

# interner Fehler
#: subst.c:5433
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "Kommandoersetzung: Kann Pipe nicht als fd 1 duplizieren."

#: subst.c:5837 subst.c:8050
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr ""

#: subst.c:6048
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: Parameter ist Null oder nicht gesetzt."

# interner Fehler
#: subst.c:6320 subst.c:6335
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: Teilstring-Ausdruck < 0."

#: subst.c:7506
#, c-format
msgid "%s: bad substitution"
msgstr "%s: Falsche Variablenersetzung."

#: subst.c:7583
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: Kann so nicht zuweisen."

#: subst.c:7917
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"Zukünftige Versionen dieser Shell werden das Auswerten arithmetischer "
"Ersetzungen erzwingen."

#: subst.c:8421
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "Falsche Ersetzung: Keine schließende \"`\" in %s."

#: subst.c:9322
#, c-format
msgid "no match: %s"
msgstr "Keine Entsprechung: %s"

#: test.c:147
msgid "argument expected"
msgstr "Argument erwartet."

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: Ganzzahliger Ausdruck erwartet."

#: test.c:264
msgid "`)' expected"
msgstr "`)' erwartet."

#: test.c:266
#, c-format
msgid "`)' expected, found %s"
msgstr "`)' erwartet, %s gefunden."

#: test.c:281 test.c:742 test.c:745
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: Einstelliger (unärer) Operator erwartet."

#: test.c:468 test.c:785
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: Zweistelliger (binärer) Operator erwartet."

#: test.c:860
msgid "missing `]'"
msgstr "Fehlende `]'"

#: trap.c:217
msgid "invalid signal number"
msgstr "Ungültige Signalnummer."

#: trap.c:371
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr ""

#: trap.c:375
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""

# Programmierfehler
#: trap.c:428
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Falsches Signal %d."

#: variables.c:382
#, c-format
msgid "error importing function definition for `%s'"
msgstr "Fehler beim Importieren der Funktionsdefinition für `%s'."

#: variables.c:780
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr ""

#: variables.c:1865
#, c-format
msgid "%s: circular name reference"
msgstr ""

#: variables.c:2228
msgid "make_local_variable: no function context at current scope"
msgstr ""

#: variables.c:2247
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: Der Variable könnte kein Wert zugewiesen sein."

#: variables.c:3646
msgid "all_local_variables: no function context at current scope"
msgstr ""

#: variables.c:3891
#, c-format
msgid "%s has null exportstr"
msgstr ""

#: variables.c:3896 variables.c:3905
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr ""

#: variables.c:3911
#, c-format
msgid "no `=' in exportstr for %s"
msgstr ""

#: variables.c:4344
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""

#: variables.c:4357
msgid "pop_var_context: no global_variables context"
msgstr ""

#: variables.c:4431
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""

#: variables.c:5257
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: Kann nicht als Datei geöffnet werden."

#: variables.c:5262
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr ""

#: variables.c:5307
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: Kompatibilitätswert außerhalb des Gültigkeitsbereiches."

#: version.c:46
msgid "Copyright (C) 2013 Free Software Foundation, Inc."
msgstr "Copyright (C) 2013 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Lizenz GPLv3+: GNU GPL Version 3 oder jünger <http://gnu.org/licenses/gpl."
"html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, Version %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Dies ist freie Software.  Sie darf verändert und verteilt werden."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr ""
"Für den größtmöglichen gesetzlich zulässigen Umfang wird jede Haftung "
"ausgeschlossen."

#: version2.c:46
msgid "Copyright (C) 2012 Free Software Foundation, Inc."
msgstr "Copyright (C) 2012 Free Software Foundation, Inc."

#: xmalloc.c:91
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: Konnte nicht %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: Konnte nicht %lu Bytes reservieren."

#: xmalloc.c:163
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: Konnte nicht %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: Konnte nicht %lu Bytes reservieren."

#: builtins.c:43
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [Name[=Wert] ... ]"

#: builtins.c:47
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] Name [Name ...]"

#: builtins.c:51
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpsvPSVX] [-m Tastaturtabelle] [-f Dateiname] [-q Name] [-u\n"
"Name] [-r Tastenfolge] [-x Tastenfolge:Shell Kommando] [Tastenfolge:readline "
"Funktion oder Kommando]"

#: builtins.c:54
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:56
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:58
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [Shellkommando [Argument ...]]"

#: builtins.c:61
msgid "caller [expr]"
msgstr "caller [Ausdruck]"

#: builtins.c:64
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [Verzeichnis]"

#: builtins.c:66
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:68
msgid ":"
msgstr ":"

#: builtins.c:70
msgid "true"
msgstr "true"

#: builtins.c:72
msgid "false"
msgstr "false"

#: builtins.c:74
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] Kommando [Argument ...]"

#: builtins.c:76
msgid "declare [-aAfFgilnrtux] [-p] [name[=value] ...]"
msgstr "declare [-aAfFgilrntux] [-p] Variable[=Wert] ..."

#
#: builtins.c:78
msgid "typeset [-aAfFgilrtux] [-p] name[=value] ..."
msgstr "typeset [-aAfFgilrtux] [-p] Name[=Wert] ..."

#: builtins.c:80
msgid "local [option] name[=value] ..."
msgstr "local [Option] Name[=Wert] ..."

#: builtins.c:83
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [Argument ...]"

#: builtins.c:87
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [Argument ...]"

#: builtins.c:90
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f Dateiname] [Name ...]"

#: builtins.c:92
msgid "eval [arg ...]"
msgstr "eval [Argument ...]"

#: builtins.c:94
msgid "getopts optstring name [arg]"
msgstr "getopts Optionen Variable [Argumente]"

#: builtins.c:96
msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a Name] [Kommando [Argumente ...]] [Umleitung ...]"

#: builtins.c:98
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:100
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:103
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e Editor] [-lnr] [Anfang] [Ende] oder fc -s [Muster=Ersetzung] "
"[Kommando]"

#: builtins.c:107
msgid "fg [job_spec]"
msgstr "fg [Jobbezeichnung]"

#: builtins.c:111
msgid "bg [job_spec ...]"
msgstr "bg [Jobbezeichnung ...]"

#: builtins.c:114
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p Pfadname] [-dt] [Name ...]"

#: builtins.c:117
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [Muster ...]"

#: builtins.c:121
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d Offset] [n] oder history -anrw [Dateiname] oder history -ps "
"Argument [Argument...]"

#: builtins.c:125
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [Jobbez. ...] or jobs -x Kommando [Arg]"

#: builtins.c:129
msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [-h] [-ar] [Jobbezeichnung ...]"

#: builtins.c:132
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s Signalname | -n Signalnummer | -Signalname] [pid | job] ... oder "
"kill -l [Signalname]"

#: builtins.c:134
msgid "let arg [arg ...]"
msgstr "let Argument [Argument ...]"

#: builtins.c:136
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a Feld] [-d Begrenzer] [-i Text] [-n Zeichenanzahl] [-N "
"Zeichenanzahl] [-p Prompt] [-t Zeitlimit] [-u fd] [Name ...]"

#: builtins.c:138
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:140
msgid "set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o Option] [--] [Argument ...]"

#: builtins.c:142
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [NAME ...]"

#: builtins.c:144
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [Name[=Wert] ...] oder export -p"

#: builtins.c:146
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [Name[=Wert] ...] oder readonly -p"

#: builtins.c:148
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:150
msgid "source filename [arguments]"
msgstr "source Dateiname [Argumente]"

#: builtins.c:152
msgid ". filename [arguments]"
msgstr ". Dateiname [Argumente]"

#: builtins.c:155
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:158
msgid "test [expr]"
msgstr "test [Ausdruck]"

#: builtins.c:160
msgid "[ arg... ]"
msgstr "[ Argument... ]"

#: builtins.c:162
msgid "times"
msgstr "times"

#: builtins.c:164
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[Argument] Signalbezeichnung ...]"

#: builtins.c:166
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] Name [Name ...]"

#: builtins.c:169
msgid "ulimit [-SHabcdefilmnpqrstuvxT] [limit]"
msgstr "ulimit [-SHabcdefilmnpqrstuvxT] [Grenzwert]"

#: builtins.c:172
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [Modus]"

#: builtins.c:175
msgid "wait [-n] [id ...]"
msgstr "wait [-n] [id ...]"

#: builtins.c:179
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:182
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for Name [in Wortliste ... ] ; do Kommandos; done"

#: builtins.c:184
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( Ausdr1; Ausdr2; Ausdr3 )); do Kommandos; done"

#: builtins.c:186
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select Name [in Wortliste ... ;] do Kommandos; done"

#: builtins.c:188
msgid "time [-p] pipeline"
msgstr "time [-p] Pipeline"

#: builtins.c:190
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case Wort in [Muster [| Muster]...) Kommandos ;;]... esac"

#: builtins.c:192
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if Kommandos; then Kommandos; [ elif Kommandos; then Kommandos; ]... [ else "
"Kommandos; ] fi"

#: builtins.c:194
msgid "while COMMANDS; do COMMANDS; done"
msgstr "while Kommandos; do Kommandos; done"

#: builtins.c:196
msgid "until COMMANDS; do COMMANDS; done"
msgstr "until Kommandos; do Kommandos; done"

#: builtins.c:198
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [Name] Kommando [Umleitungen]"

#: builtins.c:200
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function Name { Kommandos ; } oder Name () { Kommandos ; }"

#: builtins.c:202
msgid "{ COMMANDS ; }"
msgstr "{ Kommandos ; }"

#: builtins.c:204
msgid "job_spec [&]"
msgstr "Jobbezeichnung [&]"

#: builtins.c:206
msgid "(( expression ))"
msgstr "(( Ausdruck ))"

#: builtins.c:208
msgid "[[ expression ]]"
msgstr "[[ Ausdruck ]]"

#: builtins.c:210
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Namen und Bedeutung einiger Shell Variablen"

#: builtins.c:213
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | Verzeichnis]"

#: builtins.c:217
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:221
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:224
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [Optionsname ...]"

#: builtins.c:226
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] Format [Argumente]"

#: builtins.c:229
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-"
"W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o Option] [-A Aktion] [-G Suchmuster] "
"[-W Wortliste]  [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-"
"S Suffix] [Name ...]"

#: builtins.c:233
msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o Option]  [-A Aktion] [-G Suchmuster] [-W "
"Wortliste]  [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S "
"Suffix] [Wort]"

#: builtins.c:237
msgid "compopt [-o|+o option] [-DE] [name ...]"
msgstr "compopt [-o|+o Option] [-DE] [Name ...]"

#: builtins.c:240
msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"mapfile [-n Anzahl] [-O Quelle] [-s Anzahl] [-t] [-u fd] [-C Callback] [-c "
"Menge] [Feldvariable]"

#: builtins.c:242
msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"readarray [-n Anzahl] [-O Quelle] [-s Anzahl] [-t] [-u fd] [-C Callback] [-c "
"Menge] [Feldvariable]"

# alias
#: builtins.c:254
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Definiert Aliase oder zeigt sie an.\n"
"    \n"
"    Ohne Argumente wird die Liste der Aliase (Synonyme) in der Form\n"
"    `alias Name=Wert' auf die Standardausgabe ausgegeben.\n"
"\n"
"    Sonst wird ein Alias für jeden angegebenen Namen definiert, für\n"
"    den ein Wert angegeben wurde. Wenn `Wert' mit einem Leerzeichen\n"
"    abschließt, dann wird auch das folgende Wort auf Aliase überprüft.\n"
"\n"
"    Optionen:\n"
"      -p\tGibt alle definierten Aliase aus.\n"
"    \n"
"    Rückgabewert:\n"
"    Meldet Erfolg, außer wenn `Name' nicht existiert."

# unalias
#: builtins.c:276
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Entferne jeden angegebenen Namen von der Aliasliste.\n"
"    \n"
"    Optionen:\n"
"      -a\tEnferne alle Alias Definitionen.\n"
"    \n"
"    Gibt immer 0 zurück wenn der Alias existierte."

# bind
#: builtins.c:289
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X\t\t     List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Konfiguriert Readline Tastenzuordnungen und Variablen.\n"
"    \n"
"    Weist eine Tastensequenz einer Readline Funktion oder einem Makro\n"
"    zu oder setzt eine Readline Variable.  Der Argument syntax ist zu\n"
"    den Einträgen in ~/.inputrc äquivalent, aber sie müssen als\n"
"    einzelnes Argument übergeben werden.  Z.B: bind '\"\\C-x\\C-r\":\n"
"    re-read-init-file'.\n"
"    \n"
"    Optionen:\n"
"      -m  Keymap         Benutzt KEYMAP as Tastaturbelegung für die "
"Laufzeit\n"
"                         dieses Kommandos.  Gültige Keymap Namen sind: "
"emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command und vi-insert.\n"
"      -l                 Listet Funktionsnamen auf.\n"
"      -P                 Listet Funktionsnamen und Tastenzuordnungen auf.\n"
"      -p                 Listet Funktionsnamen und Tastenzuordnungen so "
"auf,\n"
"                         dass sie direkt als Eingabe verwendet werden "
"können.\n"
"      -S                 Listet Tastenfolgen und deren Werte auf, die "
"Makros \n"
"                         aufrufen.\n"
"      -s                 Listet Tastenfolgen und deren Werte auf, die "
"Makros \n"
"                         aufrufen, dass sie als Eingabe wiederverwendet "
"werden\n"
"                         können.\n"
"      -V                 Listet Variablennamen und Werte auf.\n"
"      -v                 Listet Variablennamen und Werte so auf, dass sie "
"als\n"
"                         Eingabe verwendet werden können.\n"
"      -q  Funktionsname  Sucht die Tastenfolgen, welche die angegebene\n"
"                         Funktion aufrufen.\n"
"      -u  Funktionsname  Entfernt alle der Funktion zugeordneten "
"Tastenfolgen.\n"
"      -r  Tastenfolge    Entfernt die Zuweisungen der angegebeben "
"Tastenfolge.\n"
"      -f  Dateiname      Liest die Tastenzuordnungen aus der angegebenen "
"Datei.\n"
"      -x  Tastenfolge:Shellkommando\tWeist der Tastenfolge das "
"Shellkommando\n"
"    \t\t\t\t\tzu.\n"
"      -X                                Listet mit -x erzeugte\n"
"                                        Tastenfolgen und deren Werte\n"
"                                        auf, die Makros aufrufen, dass\n"
"                                        sie als Eingabe wiederverwendet "
"werden\n"
"                                        können.\n"
"    \n"
"    Rückgabewert: \n"
"    Bind gibt 0 zurück, wenn keine unerkannte Option angegeben wurde\n"
"    oder ein Fehler eintrat."

# break
#: builtins.c:328
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Beendet for, while oder until Schleifen.\n"
"    \n"
"    Break beendet eine »for«, »while« oder »until« Schleife.  Wenn »n«\n"
"    angegeben ist, werden entsprechend viele geschachtelte Schleifen\n"
"    beendet.\n"
"    \n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer »n« ist nicht größer oder gleich 1."

# continue
#: builtins.c:340
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Springt zum Schleifenanfang von for, while, oder until Schleifen.\n"
"    \n"
"    Springt zum Schleifenanfang der aktuellen »for«, »while« oder »until«\n"
"    Schleife. Wenn »n« angegeben ist, wird zum Beginn der »n«-ten\n"
"    übergeordneten Schleife gesprungen.\n"
"    \n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer wenn »n« nicht größer oder gleich 1 ist."

# builtin
#: builtins.c:352
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""
"Führt eine in der Shell definierts Kommando aus.\n"
"    \n"
"    Führt eine in der Shell definertes Kommando aus.  Dies ist dann\n"
"    nützlich, wenn es mit gleichem Namen als Funktion reimplementiert\n"
"    werden soll, aber die Funktionalität des eingebauten Kommandos\n"
"    innerhalb der neuen Funktion benötigt wird.\n"
"    \n"
"    Rückgabewert: \n"
"    Der Rückgabewert des aufgerufenen Kommandos oder »falsch«, wenn\n"
"    dieses nicht existiert."

# caller
#: builtins.c:367
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""

# cd
#: builtins.c:385
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"        -L\tforce symbolic links to be followed: resolve symbolic links in\n"
"    \tDIR after processing instances of `..'\n"
"        -P\tuse the physical directory structure without following symbolic\n"
"    \tlinks: resolve symbolic links in DIR before processing instances\n"
"    \tof `..'\n"
"        -e\tif the -P option is supplied, and the current working directory\n"
"    \tcannot be determined successfully, exit with a non-zero status\n"
"        -@  on systems that support it, present a file with extended "
"attributes\n"
"            as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Wechselt das Arbeitsverzeichnis.\n"
"    \n"
"    Wechselt in das angegebene Abeitsverzeichnis.  Ohne Angabe eines\n"
"    Verzeichnisses wird in das Heimatverzeichnis gewechselt.\n"
"    \n"
"    Die Variable CDPATH gibt eine Liste von Orten an, in denen nach\n"
"    dem angegebeben Verzeichnisnamen gesucht wird.  Die Pfadnamen\n"
"    werden durch Doppelpunkte »:« getrennt. Ein leerer Pfadname\n"
"    bezeichnet das aktuelle Verzeichnis. Wenn ein vollständiger\n"
"    Pfadname angegeben ist, wird der CDPATH nicht durchsucht.\n"
"    \n"
"    Wenn kein entsprechendes Verzeichnis gefunden wurde und die Shell\n"
"    Option `cdable_vars' gesetzt ist, dann wird angenommen, dass der\n"
"    Verzeichnisname einen Variablennamen enthält.  Wenn diese ein Wert\n"
"    besitzt, wird dieser als Verzeichnisname verwendet.\n"
"    \n"
"    Optionen:\n"
"        -L\tErzwingt das symbolischen Verweisen gefolgt wird.\n"
"                Symbolische Links im aktuellen Verzeichnis werden nach\n"
"                dem übergeordneten Verzeichnis aufgelöst.\n"
"        -P\tSymbolische Verweise werden ignoriert. Symbolische\n"
"                Links im aktuellen Verzeichnis werden vor dem\n"
"                übergeordneten Verzeichnis aufgelöst.\n"
"        -e\tWenn mit der »-P« das aktuelle Arbeitsverzeichns nicht\n"
"                ermittelt werden kann, wird ein Rückgabwert ungleich 0\n"
"                geliefert.\n"
"        -@      Wenn es das System Unterstützt wird eine Datei mit  \n"
"                erweiterten Attributen als ein Verzeichnis angezeigt,\n"
"                welches die erweiterten Attribute enthält.\n"
"    \n"
"    Standardmäßig wird symbolischen Verweisen gefolgt (Option -L).\n"
"    Das übergeordnete Verzeichnis wird ermittelt, indem der\n"
"    Dateiname am letzten Schrägstrich gekürzt wird oder es wird der\n"
"    Anfang von DIR verwendet.\n"
"    \n"
"    Rückgabewert: \n"
"    Der Rückgabewert ist 0, wenn das Verzeichnis gewechselt wurde,\n"
"    sonst ungleich 0.\n"
"    Mit den Optionen »-P -e« wird ein Rückgabewert ungleich 0 auch\n"
"    dann gesetzt, wenn das neue aktuelle Verzeichnis nicht ermittelt\n"
"    werden konnte."

# pwd
#: builtins.c:422
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Gibt den Namen des aktuellen Arbeitsverzeichnisses aus.\n"
"    \n"
"    Optionen:\n"
"      -L\tGibt den Inhalt der Variable $PWD aus.\n"
"      -P\tGibt den physischen Verzeichnispfad aus, ohne\n"
"                symbolische Verweise.\n"
"    \n"
"    Standardmäßig wird immer die Option »-L« gesetzt.\n"
"    \n"
"    Rückgabewert:\n"
"    Ist 0 außer wenn eine ungültige Option angegeben oder das aktuelle\n"
"    Verzeichnis nicht lesbar ist."

# colon
#: builtins.c:439
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Leeranweisung.\n"
"\n"
"    Leeranweisung; das Kommando hat keine Wirkung.\n"
"\n"
"    Rückgabewert:\n"
"    Das Kommando ist immer »wahr«."

# true
#: builtins.c:450
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Gibt »wahr« zurück.\n"
"    \n"
"    Rückgabewert:\n"
"    Immer »wahr«."

#: builtins.c:459
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Gibt »falsch« zurück.\n"
"    \n"
"    Rückgabewert:\n"
"    Immer »falsch«."

# command
#: builtins.c:468
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Führt ein einfaches Kommando aus oder zeigt Informationen über Kommandos "
"an.\n"
"\n"
"    Führt das Kommando mit den angegebeneb Argumenten aus, ohne\n"
"    Shell-Funktion nachzuschlagen oder zeigt Informationen über die\n"
"    Kommandos an. Dadurch können auch dann Kommandos ausgeführt\n"
"    werden, wenn eine Shell-Funktion gleichen Namens existiert.\n"
"    \n"
"    Optionen:\n"
"      -p\tStandardwert für PATH verwenden. Dies garantiert, dass alle\n"
"    \t\tStandard-Dienstprogramme gefunden werden.\n"
"      -v\tBeschreibung des Kommandos ausgeben.\n"
"    \t\tÄhnlich dem eingebauten Kommando »type«.\n"
"      -V\tEine ausführlichere Beschreibung jedes Kommandos ausgeben.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt den Rückgabewert des Kommandos zurück, oder eine Fehlermeldung, "
"wenn\n"
"    das Kommando nicht gefunden wird."

# declare
#: builtins.c:487
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \tignored\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert NAMEs to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert NAMEs to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Setzt Variablenwerte und deren Attribute.\n"
"    \n"
"    Deklariert Variablen und weist ihnen Attribute zu. Wenn keine\n"
"    Namen angegeben sind, werden die Attribute und Werte aller\n"
"    Variablen ausgegeben.\n"
"    \n"
"    Optionen:\n"
"      -f\tZeigt nur Funktionsnamen und Definitionen an.\n"
"      -F\tZeigt nur Funktionsnamen an (inklusive Zeilennummer\n"
"    \t\tund Quelldatei beim debuggen).\n"
"      -g\tDeklariert innerhalb ener Shellfunktion globale\n"
"                Variablen; wird sonst ignoriert.\n"
"      -p\tZeigt die Attribute und Werte jeder angegebenen\n"
"                Variable an.\n"
"    \n"
"    Attribute setzen:\n"
"      -a\tDeklariert ein indiziertes Feld (wenn unterstützt).\n"
"      -A\tDeklariert ein assoziatives Feld (wenn unterstützt).\n"
"      -i\tDeklariert eine Integer Variable.\n"
"      -l\tKonvertiert die Variabennmamen in Kleinbuchstaben.\n"
"      -r\tDeklariert nur lesbare Variablen.\n"
"      -t\tWeist das »trace« Attibut zu.\n"
"      -u\tKonvertiert die Variablennamen in Großbuchstaben.\n"
"      -x\tExportiert die Variablen über die aktuelle Shell\n"
"                Umgebung hinaus.\n"
"    \n"
"    Das Voranstellen von »+« anstelle von »-« schaltet die gegebenen\n"
"    Attribute ab.\n"
"    \n"
"    Für Integer Variablen werden bei der Zuweisung arithmetische\n"
"    Berechnungen durchgeführt (siehe `help let').\n"
"    \n"
"    Innerhalb einer Funktion werden lokale Variablen erzeugt. Die\n"
"    Option »-g« unterdrückt dieses Verhalten.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer eine ungültige Option wurde angegeben,\n"
"    oder ein Fehler trat auf."

#: builtins.c:527
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""
"Setzt Variablen Werte und Eigenschaften\n"
"\n"
"    Veraltet.  Siehe `help declare'."

#: builtins.c:535
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definiert lokale Variablen.\n"
"    \n"
"    Erzeugt eine Lokale Variable NAME und weist ihr den Wert VALUE zu.\n"
"    OPTION kann eine beliebige von `declare' akzeptierte Option sein.\n"
"\n"
"    Lokale Variablen können nur innerhalb einer Funktion benutzt\n"
"    werden. Sie sind nur in der sie erzeugenden Funktion und ihren\n"
"    Kindern sichtbar.\n"
"    \n"
"    Rückgabewert: \n"
"    Liefert 0 außer bei Angabe einer ungültigen Option, einer\n"
"    fehlerhaften Variablenzuweisung oder dem Aufruf außerhalb einer\n"
"    Funktion."

# echo
#: builtins.c:552
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \tcan be one or two hex digits\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Ausgabe der Argumente auf die Standardausgabe.\n"
"    \n"
"    Zeigt die Argumente auf der Standardausgabe gefolgt von einem\n"
"    Zeilenumbruch an.\n"
"    \n"
"    Optionen:\n"
"      -n\tKeinen Zeilenumbruch anfügen\n"
"      -e\tInterpretation der folgenden Escape-Sequenzen zulassen\n"
"      -E\tKeine Interpretation der Escape-Sequenzen.\n"
"    \n"
"    »echo« interpretiert die folgenden Escape-Sequenzen:\n"
"      \\a\tAlarm (Glocke)\n"
"      \\b\tRücktaste (Backspace)\n"
"      \\c\tweitere Ausgabe unterdrücken\n"
"      \\e\tEscape-Zeichen\n"
"      \\E        Escape Zeichen\n"
"      \\f\tSeitenvorschub\n"
"      \\n\tZeilenvorschub\n"
"      \\r\tWagenrücklauf\n"
"      \\t\tHorizontaler Tabulator\n"
"      \\v\tVertikaler Tabulator\n"
"      \\\\        umgekehrter Schrägstrich (Backslash)\n"
"      \\0nnn\tZeichen mit dem ASCII-Code »NNN« (oktal). »NNN« kann null\n"
"    \t\tbis drei oktale Ziffern haben.\n"
"      \\xHH\tAcht-Bit-Zeichen mit dem Wert »HH« (hexadezimal). »HH«\n"
"    \t\tkann ein oder zwei hexadezimale Ziffern haben.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer ein Ausgabefehler tritt auf."

#: builtins.c:588
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""

# enable
#: builtins.c:603
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Eingebaute Shell-Kommandos aktivieren und deaktivieren.\n"
"    \n"
"    Aktiviert und deaktiviert eingebaute Shell-Kommandos. Die Deaktivierung\n"
"    erlaubt Ihnen, eigene Kommandos mit demselben Namen wie die eingebauten\n"
"    Kommandos zu nutzen, ohne den kompletten Pfad angeben zu müssen.\n"
"    \n"
"    Optionen:\n"
"      -a\tGibt eine Liste der eingebauten Kommandos aus inklusive der\n"
"    \t\tInformation, ob sie aktiv sind oder nicht.\n"
"\n"
"      -n\tdeaktiviert jedes angegebene Kommando oder gibt eine\n"
"                Liste der deaktivierten eingebauten Kommandos aus.\n"
"      -p\tGibt eine Liste der eingebauten Kommandos in einem\n"
"    \t\twiederverwendbaren Format aus.\n"
"      -s\tGibt nur die Namen der »speziellen« in POSIX eingebauten\n"
"    \t\tKommandos aus.\n"
"    \n"
"    Optionen zum Beeinflussen des dynamischen Ladens:\n"
"      -f\tLade eingebautes Kommando aus der angegebenen Datei.\n"
"      -d\tEntfernt ein mit »-f« geladenes Kommando.\n"
"    \n"
"    Ohne Optionen wird jedes angegebe Kommando aktiviert.\n"
"    \n"
"    Um das unter $PATH liegende Kommando »test« anstelle der eingebauten\n"
"    Version zu nutzen, geben Sie »enable -n test« ein.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer NAME ist kein eingebautes Kommando \n"
"    oder ein Fehler tritt auf."

#: builtins.c:631
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Führe die Argumente als Shell Kommando aus.\n"
"    \n"
"    Fügt die Argumente zu einer Zeichenkette zusammen und verwendet\n"
"    das Ergebnis als Eingebe in eine Shell, welche die enthaltenen\n"
"    Kommandos ausführt.\n"
"    \n"
"    Rückgabewert:\n"
"    Der Status des Kommandoe oder Erfolg wenn das Kommando leer war."

# getopts
#: builtins.c:643
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analysieren von Optionsargumenten.\n"
"    \n"
"    Getopts wird von Shell-Prozeduren verwendet, um die\n"
"    Kommandozeilenoptionen auszuwerten.\n"
"    \n"
"    \"Optionen\" enthält die auszuwertenden Buchstaben.  Ein Doppelpunkt\n"
"    nach dem Buchstaben zeigt an, dass ein Argument erwartet wird,\n"
"    welches durch ein Leerzeichen von der Option getrennt ist.\n"
"    \n"
"    Bei jedem Aufruf von »getopts« wird die nächste Option der\n"
"    $Variable zugewiesen. Diese wird angelegt, falls sie noch\n"
"    nicht existiert. Weiterhin wird der Indes Index des nächsten zu\n"
"    verarbeitenden Arguments der Shell-Variablen OPTIND\n"
"    zugewiesen. OPTIND wird bei jedem Aufruf einer Shell oder eines\n"
"    Shell-Skripts mit 1 initialisiert.  Wenn eine Option ein Argument\n"
"    benötigt, wird dieses OPTARG zugewiesen.\n"
"    \n"
"    Für Fehlermeldungen gibt es zwei Varianten.  Wenn das erste\n"
"    Zeichen des Optionsstrings ein Doppelpunkt ist, wird der stille\n"
"    Fehlermodus von »getopts« verwendet. In diesem Modus wird keine\n"
"    Fehlermeldung ausgegeben. Wenn eine ungültige Option erkannt wird,\n"
"    wird das gefundene Optionenzeichen OPTARG zugewiesen. Wenn ein\n"
"    benötigtes Argument fehlt, wird ein »:« der Variable zugewiesen\n"
"    und OPTARG auf das gefundene Optionenzeichen gesetzt.  Im anderen\n"
"    Fehlermodus wird ein »?« der Variable zugewiesen, OPTARG geleert\n"
"    und eine Fehlermeldung ausgegeben.\n"
"    \n"
"    Wenn die Shell-Variable OPTERR den Wert »0« hat, werden durch getopts \n"
"    keine Fehlermeldungen ausgegeben, auch wenn das erste Zeichen \n"
"    von OPTSTRING kein Doppelpunkt ist. OPTERR hat den Vorgabewert »1«.\n"
"    \n"
"    Getopts analysiert normalerweise die von der Position abhängigen\n"
"    Parameter ($0 - $9). Aber wenn mehr Argumente angegeben sind,\n"
"    werden stattdessen diese analysiert.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück wenn eine Option gefunden wird und\n"
"    »gescheitert«, wenn das Ende der Optionen erreicht oder ein Fehler\n"
"    aufgetreten ist."

# exec
#: builtins.c:685
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Ersetzt die Shell durch das angegebene Kommando.\n"
"    \n"
"    Führt das angebebene Kommando einschließlich dessen Optionen aus\n"
"    und ersetzt durch dieses die Shell. Wenn kein Kommando angegeben\n"
"    ist, wirken alle Weiterleitungen für die aktuellen Shell.\n"
"    \n"
"    Optionen:\n"
"      -a Name\tSetzt den Namen als nulltes Argument für das Kommando.\n"
"      -c\tFührt das Kommando in einer leeren Umgebung aus.\n"
"      -l\tSetzt einen Strich als nulltes Argument für das Kommando.\n"
"    \n"
"    Wenn das Kommando nicht ausgeführt werden kann, wird eine nicht\n"
"    interaktive Shell beendet, außer die Shell-Option »execfail« ist\n"
"    gesetzt.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer das Kommando wurde nicht gefunden oder\n"
"    ein Weiterleitungsfehler trat auf."

# exit
#: builtins.c:706
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Beendet die aktuelle Shell.\n"
"\n"
"    Beendt die die aktuelle Shell mit dem Rückgabewert N.  Wenn N nicht "
"angegeben ist,\n"
"    wird der Rückgabewert des letzten ausgeführten Kommandos übernommen."

# logout
#: builtins.c:715
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"    Beendet eine Login-Shell.\n"
"    \n"
"    Beendet eine Login-Shell mit dem Rückgabewert »n«.  Wenn logout\n"
"    nicht von einer Login-Shell aus ausgeführt wurde, wird ein Fehler\n"
"    zurückgegeben."

# fc
#: builtins.c:725
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""

#: builtins.c:755
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Bringt einen Job in den Vordergrund.\n"
"       \n"
"       Bringt den mit JOB_SPEC bezeichneten Prozess als aktuellen Job\n"
"       in den Vordergrund.  Wenn JOB_SPEC nicht angegeben ist, wird\n"
"       der zuletzt angehaltene Job verwendet.\n"
"       \n"
"       Rückgabewert:\n"
"       Status des in den Vordergrund geholten Jobs oder Fehler."

#: builtins.c:770
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Bringt einen Job in den Hintergrund.\n"
"       \n"
"       Bringt den mit JOB_SPEC bezeichneten Job in den Hintergrund,\n"
"       als ob er mit »&« gestartet wurde.\n"
"       \n"
"       Rückgabewert:\n"
"       Immer Erfolg, außer wenn die Jobsteuerung nicht verfügbar ist\n"
"       oder ein Fehler auftritt."

#: builtins.c:784
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\t\tforget the remembered location of each NAME\n"
"      -l\t\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\t\tforget all remembered locations\n"
"      -t\t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""

#: builtins.c:809
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""

#: builtins.c:833
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""

#: builtins.c:869
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""

#: builtins.c:896
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""

#: builtins.c:915
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""

#: builtins.c:938
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""

#: builtins.c:983
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\t\tuse Readline to obtain the line in an interactive shell\n"
"      -i text\tUse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than NCHARS\n"
"    \t\tcharacters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any delimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\t\tdo not allow backslashes to escape any characters\n"
"      -s\t\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of input "
"is\n"
"    \t\tnot read within TIMEOUT seconds.  The value of the TMOUT\n"
"    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns immediately,\n"
"    \t\twithout trying to read any data, returning success only if\n"
"    \t\tinput is available on the specified file descriptor.  The\n"
"    \t\texit status is greater than 128 if the timeout is exceeded\n"
"      -u fd\t\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""

#: builtins.c:1028
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""

#: builtins.c:1041
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG trap is inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""

#: builtins.c:1126
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""

#: builtins.c:1148
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1167
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions, depending "
"on\n"
"            whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1189
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""

#: builtins.c:1201 builtins.c:1216
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""

#: builtins.c:1232
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""

#: builtins.c:1248
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR\t True if the shell variable VAR is set\n"
"      -R VAR\t True if the shell variable VAR is set and is a name "
"reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""

# [
#: builtins.c:1329
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Wertet einen bedingen Ausdruck aus.\n"
"    \n"
"    Dieses Kommando entspricht dem »test« Kommando. Jedoch muss das\n"
"    letzte Argument ein »]« sein, welches die öffnende Klammer »[«\n"
"    schließt."

# times
#: builtins.c:1338
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Zeigt den Zeitverbrauch an.\n"
"    \n"
"    Gibt den kumulierte Nutzer- und Sysemzeitverbrauch der Shell und\n"
"    aller von ihr gestarteten Prozesse aus.\n"
"    \n"
"    Rückgabewert:\n"
"    Immer 0."

#: builtins.c:1350
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""

#: builtins.c:1386
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""

#: builtins.c:1417
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -T    the maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1465
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""

#: builtins.c:1485
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a a job specification, waits for all "
"processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for the next job to terminate and\n"
"    returns its exit status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given."
msgstr ""

#: builtins.c:1506
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""

#: builtins.c:1521
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1535
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1553
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1574
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""

#: builtins.c:1591
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1603
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1620
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1632
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1644
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""

#: builtins.c:1658
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""

#: builtins.c:1672
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1684
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""

# (( ))
#: builtins.c:1699
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Wertet arithmetische Ausdrücke aus.\n"
"\n"
"       Der Ausdruck wird nach den Regeln für arithmetische\n"
"       Berechnungen ausgewertet.  Diese Schreibweise entspricht \"let\n"
"       Ausdruck\".\n"
"\n"
"       Rückgabewert: \n"
"       Gibt »1« zurück, wenn die Auswertung des letzten Arguments Null\n"
"       ergibt, sonst »0«."

#: builtins.c:1711
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""

# variable_help
#: builtins.c:1737
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"    BASH_VERSION\tVersionsnummer der Bash.\n"
"    CDPATH\tEine durch Doppelpunkte getrennte Liste von\n"
"                Verzeichnissen, die durchsucht werden, wenn das\n"
"                Argument von `cd' nicht im aktuellen Verzeichnis\n"
"                gefunden wird.\n"
"    GLOBIGNORE  Eine durch Doppelpunkte getrennte Liste von\n"
"                Dateinamenmustern, die für die Dateinamensergänzung\n"
"                ignoriert werden.\n"
"    HISTFILE\tDatei, die den Kommandozeilenspeicher enthält.\n"
"    HISTFILESIZE\tMaximale Zeilenanzahl, dieser Datei.\n"
"    HISTSIZE\tMaximale Anzahl von Zeilen, auf die der\n"
"                Historymechanismus der Shell zurückgreifen kann.\n"
"    HOME\tHeimatverzeichnis des aktuellen Benutzers.\n"
"    HOSTNAME    Der aktuelle Rechnername.\n"
"    HOSTTYPE\tCPU-Typ des aktuellen Rechners.\n"
"    IGNOREEOF\tLegt die Reaktion der Shell auf ein EOF-Zeichen fest.\n"
"                Wenn die Variable eine ganze Zahl enthält, wird diese\n"
"                Anzahl EOF Zeichen (Ctrl-D) abgewartet, bis die Shell\n"
"                verlassen wird.  Der Vorgabewert ist 10. Ist IGNOREEOF\n"
"                nicht gesetzt, signalisiert EOF das Ende der Eingabe.\n"
"    MACHTYPE    Eine Zeichenkette die das aktuell laufende System "
"beschreibt.\n"
"    MAILCHECK\tZeit in s, nach der nach E-Mail gesehen wird.\n"
"    MAILPATH\tEine durch Doppelpunkt getrennte Liste von Dateinamen,\n"
"                die nach E-Mail durchsucht werden.\n"
"    OSTYPE\tUnix Version, auf der die Bash gegenwärtig läuft.\n"
"    PATH\tDurch Doppelpunkt getrennte Liste von Verzeichnissen,\n"
"                die nach Kommandos durchsucht werden.\n"
"    PROMPT_COMMAND\tKommando, das vor der Anzeige einer primären\n"
"                        Eingabeaufforderung (PS1) ausgeführt wird.\n"
"    PS1                 Zeichenkette, die die primäre\n"
"                        Eingabeaufforderung enthält.\n"
"    PS2                 Zeichenkette, die die sekundäre\n"
"                        Eingabeaufforderung enthält.\n"
"    PWD                 Der vollständige aktuelle Verzeichnisname.\n"
"    SHELLOPTS           Durch Doppelpunkt getrennte Liste der aktiven\n"
"                        Shell Optionen.\n"
"    TERM\tName des aktuellen Terminaltyps.\n"
"    auto_resume Ein Wert ungleich Null bewirkt, daß ein einzelnes\n"
"                Kommando auf einer Zeile zunächst in der Liste\n"
"                gegenwärtig gestoppter Jobs gesucht und dieser in den\n"
"                Vordergrund geholt wird. `exact' bewirkt, daß das\n"
"                Kommando genau dem Kommando in der Liste der\n"
"                gestoppten Jobs entsprechen muß. Wenn die Variable den\n"
"                Wert `substring' enthält, muß das Kommando einem\n"
"                Substring der Jobbezeichnung entsprechen. Bei einem\n"
"                anderen Wert müssen die ersten Zeichen übereinstimmen.\n"
"    histchars         Zeichen, die die Befehlswiederholung und die\n"
"                      Schnellersetzung steuern. An erster Stelle steht\n"
"                      das Befehlswiederholungszeichen (normalerweise\n"
"                      `!'); an zweiter das `Schnell-Ersetzen-Zeichen'\n"
"                      (normalerweise `^'). Das dritte Zeichen ist das\n"
"                      `Kommentarzeichen' (normalerweise `#').\n"
"    HISTIGNORE        Eine durch Doppelpunkt getrennte Liste von\n"
"                      Mustern, welche die in der\n"
"                      Befehlswiederholungsliste zu speichernden\n"
"                      Kommandos angibt.\n"

# pushd
#: builtins.c:1794
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Fügt ein Verzeichnis dem Stapel hinzu.\n"
"\n"
"    Legt ein Verzeichnisnamen auf den Verzeichnisstapel oder rotiert\n"
"    diesen so,daß das Arbeitsverzeichnis auf der Spitze des Stapels\n"
"    liegt. Ohne angegebene Argumente werden die obersten zwei\n"
"    Verzeichnisse auf dem Stapel getauscht.\n"
"\n"
"    Optionen:\n"
"    -n\tunterdrückt das Wechseln in das Verzeichnis beim Hinzufügen\n"
"        zum Stapel, so daß nur der Stapel verändert wird.\n"
"\n"
"    Argumente:\n"
"    +N\tRotiert den Stapel so, daß das N'te Verzeichnis\n"
"    (angezeigt von `dirs',gezählt von links) sich an der Spitze des\n"
"    Stapels befindet.\n"
"\n"
"    -N\tRotiert den Stapel so, daß das N'te Verzeichnis (angezeigt von\n"
"        -`dirs',gezählt von rechts) sich an der Spitze des Stapels\n"
"        -befindet.\n"
"    \n"
"\n"
"    DIR\tLegt DIR auf die Spitze des Verzeichnisstapels und wechselt "
"dorthin.\n"
"\n"
"    Der Verzeichnisstapel kann mit dem Kommando `dirs' angezeigt\n"
"    werden.\n"
"\n"
"    Rückgabewert: \n"
"    Gibt Erfolg zurück, außer wenn ein ungültiges Argument angegeben\n"
"    wurde oder der Verzeichniswechsel nicht erfolgreich war."

# popd
#: builtins.c:1828
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Entfernt Einträge vom Verzeichnisstapel.\n"
"\n"
"    Entfernt Einträge vom Verzeichnisstapel. Ohne Argumente wird die\n"
"    Spitze des Stapels entfernt und in das Verzeichnis gewechselt, das\n"
"    dann an der Spitze steht.\n"
"\n"
"    Optionen:\n"
"    -n\tEntfernt nur den Verzeichniseintrag und wechselt nicht\n"
"       \tdas Verzeichnis.\n"
"          \n"
"    Argumente:\n"
"    +N\tEntfernt den N-ten Eintrag von links, gezählt von       \t\n"
"        Null, aus der von »dirs« anzeigten Liste. Beispielsweise\n"
"        entfernen »popd +0« den ersten und »popd +1« den zweiten\n"
"        Verzeichniseintrag.\n"
"\n"
"    -N\tEntfernt den N-ten Eintrag von rechts, gezählt von Null,\n"
"      \taus der von »dirs« angeigten Liste. Beispielsweise entfernen\n"
"        »popd -0« den letzten und »popd -1« den vorletzten\n"
"        Verzeichniseintrag.\n"
"\n"
"        Mit »dirs« kann der Verzeichnisstapel angezeigt werden.\n"
"\n"
"        Rückgabewert:\n"
"        Gibt 0 zurück, außer wenn ein ungültiges Argument angegeben\n"
"        wurde oder der Verzeichniswechsel nicht erfolgreich war."

# dirs
#: builtins.c:1858
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zeigt den Verzeichnisstapel an.\n"
"\n"
"    Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse.\n"
"    Diese werden mit dem `pushd' Kommando eingetragen und mit dem\n"
"    `popd' Kommando ausgelesen.\n"
"\n"
"    Optionen:\n"
"      -c        Löscht den Verzeichnisstapel.\n"
"      -l        Keine Abkürzung für das Heimatverzeichnis durch die\n"
"                Tilde (~).\n"
"      -p        Ausgabe von einem Eintrag pro Zeile.\n"
"      -v        Ausgabe von einem Eintrag pro Zeile mit Angabe der\n"
"                Position im Stapel<\n"
"\n"
"    Argumente:\n"
"      +N        Gibt das N'te Element von links der Liste aus, die\n"
"                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
"                bei 0.\n"
"      -N        Gibt das N'te Element von rechts der Liste aus, die\n"
"                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
"                bei 0.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, außer bei einer ungültigen Option oder wenn\n"
"    ein Fehler auftritt."

#: builtins.c:1887
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not "
"each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Setzt oder löscht Shell Optionen.\n"
"\n"
"    Ändert die in `Optionsname' genannten Shell Optionen.  Ohne\n"
"    Argumente wird eine Liste der Shell Optionen un deren Stati\n"
"    ausgegeben.\n"
"\n"
"    Optionen:\n"
"      -o        Beschränkt die Optionsmanen auf die, welche mit \n"
"                `set -o' definiert werden müssen.\n"
"      -p        Gibt alle Shelloptionen und deren Stati aus.\n"
"      -q        Unterdrückt Ausgaben.\n"
"      -s        Setzt jede Option in `Optionsname.'\n"
"      -u        Deaktiviert jede Option in `Optionsname'.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, wenn eine Option gesetzt worden ist.  Wenn\n"
"    eine ungültige Option angegeben wurde oder eine Option deaktiviert\n"
"    worden ist, wird Fehler zurückgegeben."

# formatf
#: builtins.c:1908
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %(fmt)T output the date-time string resulting from using FMT as a "
"format\n"
"            string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""

#: builtins.c:1942
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \tcompletion attempted on a blank line\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.  The -D option takes\n"
"    precedence over -E.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1970
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1985
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""

# mapfile
#: builtins.c:2015
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied.\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0.\n"
"      -s count \tDiscard the first COUNT lines read.\n"
"      -t\t\tRemove a trailing newline from each line read.\n"
"      -u fd\t\tRead lines from file descriptor FD instead of the standard "
"input.\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
"      -c quantum\tSpecify the number of lines read between each call to "
"CALLBACK.\n"
"    \n"
"    Arguments:\n"
"      ARRAY\t\tArray variable name to use for file data.\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""

# readarray
#: builtins.c:2049
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Liest Zeilen einer Datei in eine Array Variable.\n"
"\n"
"    Ist ein Synonym für `mapfile'."
