# Japanese messages for GNU bash
# Copyright (C) 1999, 2010, 2011, 2013 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Kyoichi Ozaki <k@afromania.org>, 2000.
# Yasuaki Taniguchi <yasuakit@gmail.com>, 2011.
# Takeshi Hamasaki <hmatrjp@users.sourceforge.jp>, 2011, 2013.
msgid ""
msgstr ""
"Project-Id-Version: GNU bash 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-11 11:19-0500\n"
"PO-Revision-Date: 2013-03-12 19:44+0900\n"
"Last-Translator: Takeshi Hamasaki <hmatrjp@users.sourceforge.jp>\n"
"Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
"Language: Japanese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.5.4\n"

#: arrayfunc.c:51
msgid "bad array subscript"
msgstr "誤った配列の添字"

#: arrayfunc.c:356 builtins/declare.def:566
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: インデックス配列から連想配列に変換することはできません"

#: arrayfunc.c:539
#, c-format
msgid "%s: invalid associative array key"
msgstr "%s: 無効な連想配列のキーです"

#: arrayfunc.c:541
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: 配列の添字に非数字を設定できません"

#: arrayfunc.c:586
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: 連想配列を設定するときには添字をつけなければいけません"

#: bashhist.c:388
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: %s を作成できません"

#: bashline.c:3982
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: コマンドのキーマップがありません"

#: bashline.c:4069
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: 最初の非空白類文字が `\"' ではありません"

#: bashline.c:4098
#, c-format
msgid "no closing `%c' in %s"
msgstr "閉じる `%c' が %s にありません"

#: bashline.c:4132
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: 区切り文字コロン(:)がありません"

#: braces.c:321
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr ""

#: braces.c:413
#, c-format
msgid "brace expansion: failed to allocate memory for %d elements"
msgstr ""

#: braces.c:452
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr ""

#: builtins/alias.def:132
#, c-format
msgid "`%s': invalid alias name"
msgstr "`%s': 無効なエイリアス名です"

#: builtins/bind.def:123 builtins/bind.def:126
msgid "line editing not enabled"
msgstr "行編集が有効になっていません"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': 無効なキーマップ名です"

#: builtins/bind.def:251
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: %s を読み込めません"

#: builtins/bind.def:266
#, c-format
msgid "`%s': cannot unbind"
msgstr "`%s': 割り当て解除できません"

#: builtins/bind.def:304 builtins/bind.def:334
#, c-format
msgid "`%s': unknown function name"
msgstr "`%s': 不明な関数名です"

#: builtins/bind.def:312
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s はどのキーにも割り当てられていません。\n"

#: builtins/bind.def:316
#, c-format
msgid "%s can be invoked via "
msgstr "%s は次を通して起動します "

#: builtins/break.def:77 builtins/break.def:117
msgid "loop count"
msgstr "ループ回数"

#: builtins/break.def:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "`for'、`while' または `until' ループでのみ意味があります"

#: builtins/caller.def:134
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr ""
"現在のサブルーチン呼び出しのコンテキストを返します。\n"
"    \n"
"    EXPR が無い場合、次を返します "

#: builtins/cd.def:319
msgid "HOME not set"
msgstr "HOME が設定されていません"

#: builtins/cd.def:327 builtins/common.c:166 test.c:876
msgid "too many arguments"
msgstr "引数が多すぎます"

#: builtins/cd.def:338
msgid "OLDPWD not set"
msgstr "OLDPWD が設定されていません"

#: builtins/common.c:101
#, c-format
msgid "line %d: "
msgstr "%d 行: "

#: builtins/common.c:139 error.c:265
#, c-format
msgid "warning: "
msgstr "警告: "

#: builtins/common.c:153
#, c-format
msgid "%s: usage: "
msgstr "%s: 使用法: "

#: builtins/common.c:191 shell.c:506 shell.c:788
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: オプションには引数が必要です"

#: builtins/common.c:198
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: 数字の引数が必要です"

#: builtins/common.c:205
#, c-format
msgid "%s: not found"
msgstr "%s: 見つかりません"

#: builtins/common.c:214 shell.c:801
#, c-format
msgid "%s: invalid option"
msgstr "%s: 無効なオプションです"

#: builtins/common.c:221
#, c-format
msgid "%s: invalid option name"
msgstr "%s: 無効なオプション名です"

#: builtins/common.c:228 general.c:235 general.c:240
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': 有効な識別子ではありません"

#: builtins/common.c:238
msgid "invalid octal number"
msgstr "無効な八進数です"

#: builtins/common.c:240
msgid "invalid hex number"
msgstr "無効な十六進数です"

#: builtins/common.c:242 expr.c:1470
msgid "invalid number"
msgstr "無効な数字です"

#: builtins/common.c:250
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: 無効なシグナル指定です"

#: builtins/common.c:257
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': pid または有効なジョブ指定ではありません"

#: builtins/common.c:264 error.c:488
#, c-format
msgid "%s: readonly variable"
msgstr "%s: 読み取り専用の変数です"

#: builtins/common.c:272
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s が範囲外です"

#: builtins/common.c:272 builtins/common.c:274
msgid "argument"
msgstr "引数"

#: builtins/common.c:274
#, c-format
msgid "%s out of range"
msgstr "%s が範囲外です"

#: builtins/common.c:282
#, c-format
msgid "%s: no such job"
msgstr "%s: そのようなジョブはありません"

#: builtins/common.c:290
#, c-format
msgid "%s: no job control"
msgstr "%s: ジョブ制御が無効になっています"

#: builtins/common.c:292
msgid "no job control"
msgstr "ジョブ制御が無効になっています"

#: builtins/common.c:302
#, c-format
msgid "%s: restricted"
msgstr "%s: 制限されています"

#: builtins/common.c:304
msgid "restricted"
msgstr "制限されています"

#: builtins/common.c:312
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: シェルのビルトイン関数ではありません"

#: builtins/common.c:321
#, c-format
msgid "write error: %s"
msgstr "書き込みエラー: %s"

#: builtins/common.c:329
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "ターミナル属性の設定時にエラーが発生しました : %s"

#: builtins/common.c:331
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "ターミナル属性の取得時にエラーが発生しました : %s"

#: builtins/common.c:563
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: カレントディレクトリの取得時にエラーが発生しました : %s: %s\n"

#: builtins/common.c:629 builtins/common.c:631
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: 曖昧なジョブ指定です"

#: builtins/complete.def:277
#, c-format
msgid "%s: invalid action name"
msgstr "%s: 無効なアクション名です"

#: builtins/complete.def:450 builtins/complete.def:645
#: builtins/complete.def:855
#, c-format
msgid "%s: no completion specification"
msgstr "%s: 補完指定がありません"

#: builtins/complete.def:697
msgid "warning: -F option may not work as you expect"
msgstr "警告: -F オプションは期待通りに動作しないかもしれません"

#: builtins/complete.def:699
msgid "warning: -C option may not work as you expect"
msgstr "警告: -C オプションは期待通りに動作しないかもしれません"

#: builtins/complete.def:828
msgid "not currently executing completion function"
msgstr "補完機能は現在実行されていません"

#: builtins/declare.def:126
msgid "can only be used in a function"
msgstr "関数の中でのみ使用できます"

#: builtins/declare.def:315 builtins/declare.def:509
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr ""

#: builtins/declare.def:324
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr ""

#: builtins/declare.def:398
msgid "cannot use `-f' to make functions"
msgstr "関数作成時に `-f' を使用できません"

#: builtins/declare.def:410 execute_cmd.c:5361
#, c-format
msgid "%s: readonly function"
msgstr "%s: 読み取り専用関数です"

#: builtins/declare.def:553
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: この方法で配列変数を消去することはできません"

#: builtins/declare.def:560 builtins/read.def:733
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: 連想配列からインデックス配列に変換することはできません"

#: builtins/enable.def:137 builtins/enable.def:145
msgid "dynamic loading not available"
msgstr "動的ロードは利用できません"

#: builtins/enable.def:312
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "共有オブジェクト %s を開くことができません : %s"

#: builtins/enable.def:335
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "%s が共有オブジェクト %s に存在しません: %s"

#: builtins/enable.def:459
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: 動的にロードされていません"

#: builtins/enable.def:474
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: 削除できません: %s"

#: builtins/evalfile.c:140 builtins/hash.def:171 execute_cmd.c:5208
#: shell.c:1481
#, c-format
msgid "%s: is a directory"
msgstr "%s: ディレクトリです"

#: builtins/evalfile.c:146
#, c-format
msgid "%s: not a regular file"
msgstr "%s: 通常ファイルではありません"

#: builtins/evalfile.c:155
#, c-format
msgid "%s: file is too large"
msgstr "%s: ファイルが大きすぎます"

#: builtins/evalfile.c:190 builtins/evalfile.c:208 shell.c:1491
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: バイナリファイルを実行できません"

#: builtins/exec.def:154 builtins/exec.def:156 builtins/exec.def:228
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: 実行できません: %s"

#: builtins/exit.def:65
#, c-format
msgid "logout\n"
msgstr "ログアウト\n"

#: builtins/exit.def:88
msgid "not login shell: use `exit'"
msgstr "ログインシェルではありません: `exit' を使用してください"

#: builtins/exit.def:120
#, c-format
msgid "There are stopped jobs.\n"
msgstr "停止しているジョブがあります。\n"

#: builtins/exit.def:122
#, c-format
msgid "There are running jobs.\n"
msgstr "動作中のジョブがあります。\n"

#: builtins/fc.def:262
msgid "no command found"
msgstr "コマンドが見つかりません"

#: builtins/fc.def:320 builtins/fc.def:369
msgid "history specification"
msgstr "ヒストリ指定"

#: builtins/fc.def:390
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: 一時ファイルを開くことができません: %s"

#: builtins/fg_bg.def:149 builtins/jobs.def:282
msgid "current"
msgstr "カレント"

#: builtins/fg_bg.def:158
#, c-format
msgid "job %d started without job control"
msgstr "ジョブ %d がジョブ制御なしで開始されました"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: 不正なオプションです -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: オプションには引数が必要です -- %c\n"

#: builtins/hash.def:92
msgid "hashing disabled"
msgstr "ハッシュが無効になっています"

#: builtins/hash.def:138
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: ハッシュテーブルが空です\n"

#: builtins/hash.def:245
#, c-format
msgid "hits\tcommand\n"
msgstr "hits\tcommand\n"

#: builtins/help.def:130
#, c-format
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "キーワードに一致したシェルコマンド `"

#: builtins/help.def:182
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"`%s' に一致するヘルプ項目がありません。`help help'、`man -k %s' または `info "
"%s' を試してください"

#: builtins/help.def:199
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: 開くことができません: %s"

#: builtins/help.def:485
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"これらのシェルコマンドは内部で定義されています。`help' と入力して一覧を参照し"
"てください。\n"
"`help 名前' と入力すると `名前' という関数のより詳しい説明が得られます。\n"
"'info bash' を使用するとシェル全般のより詳しい説明が得られます。\n"
"`man -k' または info を使用すると一覧にないコマンドのより詳しい説明が得られま"
"す。\n"
"\n"
"名前の後にアスタリスク (*) がある場合はそのコマンドが無効になっていることを意"
"味します。\n"
"\n"

#: builtins/history.def:154
msgid "cannot use more than one of -anrw"
msgstr "-anrw を2つ以上一緒に使用することはできません"

#: builtins/history.def:186
msgid "history position"
msgstr "ヒストリ位置"

#: builtins/history.def:366
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: ヒストリの展開に失敗しました"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib が失敗しました"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "`-x' は他のオプションを同時に使用できません"

#: builtins/kill.def:200
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: 引数はプロセスIDかジョブIDでなければいけません"

#: builtins/kill.def:263
msgid "Unknown error"
msgstr "不明なエラーです"

#: builtins/let.def:95 builtins/let.def:120 expr.c:583 expr.c:598
msgid "expression expected"
msgstr "式が予期されます"

#: builtins/mapfile.def:172
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: インデックス配列ではありません"

#: builtins/mapfile.def:259 builtins/read.def:302
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: 無効なファイル記述子指定です"

#: builtins/mapfile.def:267 builtins/read.def:309
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: 無効なファイル記述子: %s"

#: builtins/mapfile.def:276 builtins/mapfile.def:314
#, c-format
msgid "%s: invalid line count"
msgstr "%s: 無効な行数です"

#: builtins/mapfile.def:287
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: 無効な配列の原点です"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: コールバックの quantum が無効です"

#: builtins/mapfile.def:336
msgid "empty array variable name"
msgstr "空の配列変数名です"

#: builtins/mapfile.def:357
msgid "array variable support required"
msgstr "配列変数のサポートが必要です"

#: builtins/printf.def:402
#, c-format
msgid "`%s': missing format character"
msgstr "`%s': 書式指定文字がありません"

#: builtins/printf.def:456
#, c-format
msgid "`%c': invalid time format specification"
msgstr "`%c': 無効な時間書式指定です"

#: builtins/printf.def:658
#, c-format
msgid "`%c': invalid format character"
msgstr "`%c': 無効な書式指定文字です"

#: builtins/printf.def:684
#, c-format
msgid "warning: %s: %s"
msgstr "警告: %s: %s"

#: builtins/printf.def:768
#, c-format
msgid "format parsing problem: %s"
msgstr ""

#: builtins/printf.def:865
msgid "missing hex digit for \\x"
msgstr "\\x 用の十六進数字がありません"

#: builtins/printf.def:880
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "\\%c 用のユニコード数値がありません"

#: builtins/pushd.def:195
msgid "no other directory"
msgstr "他のディレクトリはありません"

#: builtins/pushd.def:354
#, fuzzy, c-format
msgid "%s: invalid argument"
msgstr "%s: limit の無効な引数です"

#: builtins/pushd.def:468
msgid "<no current directory>"
msgstr "<カレントディレクトリがありません>"

#: builtins/pushd.def:512
msgid "directory stack empty"
msgstr "ディレクトリスタックが空です"

#: builtins/pushd.def:514
msgid "directory stack index"
msgstr "ディレクトリスタックのインデックス"

#: builtins/pushd.def:689
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"現在記憶されているディレクトリスタックを表示します。ディレクトリは `pushd'\n"
"    コマンドによってスタックの一番上に保存されます。`popd'コマンドによって\n"
"    スタックから取り戻すことができます。\n"
"    \n"
"    オプション:\n"
"      -c\tディレクトリスタックからすべての要素を取り除き空にする\n"
"      -l\tホームディレクトリからの相対パスを ~ を利用した形式で\n"
"    \t表示しない\n"
"      -p\tディレクトリスタックの要素を1行毎に表示する\n"
"      -v\tディレクトリスタックの要素を1行ごとに番号をつけて\n"
"    \t表示する\n"
"    \n"
"    引数:\n"
"      +N\tオプションなしで起動された場合にリストの先頭から数えて\n"
"    \tN番目の要素を表示します。開始番号は0です。\n"
"    \n"
"      -N\tオプションなしで起動された場合にリストの末尾から数えて\n"
"\tN番目の要素を表示します。開始番号は0です。"

#: builtins/pushd.def:711
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"ディレクトリスタックの先頭にディレクトリを追加します。またはディレクトリ\n"
"    スタックを回転します。新しいスタックの先頭がカレントディレクトリにな\n"
"    ります。引数なしで起動された場合、先頭の2つのディレクトリを交換します。\n"
"    \n"
"    オプション:\n"
"      -n\tスタックにディレクトリを追加した時に通常のディレクトリ変更\n"
"    \tを抑止します。よって、スタックのみ操作されます。\n"
"    \n"
"    引数:\n"
"      +N\t先頭がN番目のディレクトリになるように回転します(`dirs'で\n"
"    \t表示されるスタックの先頭から数えた数です。開始番号は0です)。\n"
"    \n"
"      -N\t先頭がN番目のディレクトリになるように回転します(`dirs'で\n"
"    \t表示されるスタックの末尾から数えた数です。開始番号は0です)。\n"
"    \n"
"      ディレクトリ\tディレクトリをスタックの先頭に加え、そのディレク\n"
"    \tトリを新しいカレントディレクトリにします。\n"
"    \n"
"    `dirs' ビルトインコマンドでディレクトリスタックを表示します。"

#: builtins/pushd.def:736
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"ディレクトリスタックから要素を削除します。引数が無い場合スタックの先頭から\n"
"    削除し、新しいスタックの先頭ディレクトリに移動します。\n"
"    \n"
"    オプション:\n"
"      -n\tスタックからディレクトリを削除した時に通常のディレクトリ変更\n"
"    \tを抑止します。よって、スタックのみ操作されます。\n"
"    \n"
"    引数:\n"
"      +N\tディレクトリスタック(`dirs' で表示される)の先頭から数えて\n"
"    \t N 番目の要素を削除します。開始番号は 0 です。例: `popd +0'\n"
"    \tは最初のディレクトリを削除します。`popd +1' は2番目です。\n"
"    \n"
"      -N\tディレクトリスタック(`dirs' で表示される)の最後から数えて\n"
"    \t N 番目の要素を削除します。開始番号は 0 です。例: `popd +0'\n"
"    \tは最後のディレクトリを削除します。`popd +1' は最後から2番目です。\n"
"    \n"
"    `dirs' ビルトインコマンドでディレクトリスタックを表示します。"

#: builtins/read.def:275
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: 無効なタイムアウト指定です"

#: builtins/read.def:678
#, c-format
msgid "read error: %d: %s"
msgstr "読み込みエラー: %d: %s"

#: builtins/return.def:75
msgid "can only `return' from a function or sourced script"
msgstr "`return' は関数または source されたスクリプト内のみで利用できます"

#: builtins/set.def:782
msgid "cannot simultaneously unset a function and a variable"
msgstr "変数と関数を同時に消去することはできません"

#: builtins/set.def:826
#, c-format
msgid "%s: cannot unset"
msgstr "%s: 消去できません"

#: builtins/set.def:843
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: 消去できません: %s は読み取り専用です"

#: builtins/set.def:854
#, c-format
msgid "%s: not an array variable"
msgstr "%s: 配列変数ではありません"

#: builtins/setattr.def:187
#, c-format
msgid "%s: not a function"
msgstr "%s: 関数ではありません"

#: builtins/shift.def:71 builtins/shift.def:77
msgid "shift count"
msgstr "シフト回数"

#: builtins/shopt.def:279
msgid "cannot set and unset shell options simultaneously"
msgstr "シェルオプションを同時に有効かつ無効にできません"

#: builtins/shopt.def:346
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: 無効なシェルオプション名です"

#: builtins/source.def:130
msgid "filename argument required"
msgstr "ファイル名が引数として必要です"

#: builtins/source.def:155
#, c-format
msgid "%s: file not found"
msgstr "%s: ファイルが見つかりません"

#: builtins/suspend.def:101
msgid "cannot suspend"
msgstr "中断できません"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "ログインシェルを中断できません"

#: builtins/type.def:234
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s は `%s' のエイリアスです\n"

#: builtins/type.def:255
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s はシェルの予約語です\n"

#: builtins/type.def:274
#, c-format
msgid "%s is a function\n"
msgstr "%s は関数です\n"

#: builtins/type.def:296
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s はシェル組み込み関数です\n"

#: builtins/type.def:317 builtins/type.def:393
#, c-format
msgid "%s is %s\n"
msgstr "%s は %s です\n"

#: builtins/type.def:337
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s はハッシュされています (%s)\n"

#: builtins/ulimit.def:383
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: limit の無効な引数です"

#: builtins/ulimit.def:409
#, c-format
msgid "`%c': bad command"
msgstr "`%c': 誤ったコマンドです"

#: builtins/ulimit.def:438
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: limit を取得できません: %s"

#: builtins/ulimit.def:464
msgid "limit"
msgstr "limit"

#: builtins/ulimit.def:476 builtins/ulimit.def:776
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: limit を変更できません : %s"

#: builtins/umask.def:114
msgid "octal number"
msgstr "八進数"

#: builtins/umask.def:227
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': 無効なシンボリックモード演算子です"

#: builtins/umask.def:282
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': 無効なシンボリックモード文字です"

#: error.c:90 error.c:325 error.c:327 error.c:329
msgid " line "
msgstr " 行 "

#: error.c:165
#, c-format
msgid "last command: %s\n"
msgstr "最後のコマンド: %s\n"

#: error.c:173
#, c-format
msgid "Aborting..."
msgstr "中止しています..."

#: error.c:440
msgid "unknown command error"
msgstr "不明なコマンドエラーです"

#: error.c:441
msgid "bad command type"
msgstr "誤ったコマンドタイプです"

#: error.c:442
msgid "bad connector"
msgstr "誤った接続です"

#: error.c:443
msgid "bad jump"
msgstr "誤ったジャンプです"

#: error.c:481
#, c-format
msgid "%s: unbound variable"
msgstr "%s: 未割り当ての変数です"

#: eval.c:189
#, c-format
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\a入力待ちがタイムアウトしました: 自動ログアウト\n"

#: execute_cmd.c:512
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "/dev/null から標準入力に対してリダイレクトできません: %s"

#: execute_cmd.c:1233
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': 無効な書式文字です"

#: execute_cmd.c:2287
msgid "pipe error"
msgstr "パイプエラー"

#: execute_cmd.c:4386
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr ""

#: execute_cmd.c:4884
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: 制限されています:  `/' をコマンド名の中に指定できません"

#: execute_cmd.c:4973
#, c-format
msgid "%s: command not found"
msgstr "%s: コマンドが見つかりません"

#: execute_cmd.c:5206
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5243
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: 誤ったインタプリタです"

#: execute_cmd.c:5280
#, fuzzy, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: バイナリファイルを実行できません"

#: execute_cmd.c:5352
#, fuzzy, c-format
msgid "`%s': is a special builtin"
msgstr "%s はシェル組み込み関数です\n"

#: execute_cmd.c:5404
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "fd %d を fd %d に複製できません"

#: expr.c:259
msgid "expression recursion level exceeded"
msgstr "式の再帰可能レベルを越えました"

#: expr.c:283
msgid "recursion stack underflow"
msgstr "再帰スタックがアンダーフローしました"

#: expr.c:431
msgid "syntax error in expression"
msgstr "式に構文エラーがあります"

#: expr.c:475
msgid "attempted assignment to non-variable"
msgstr "非変数に割り当てを行おうとしてます"

#: expr.c:495 expr.c:858
msgid "division by 0"
msgstr "0 による除算です"

#: expr.c:542
msgid "bug: bad expassign token"
msgstr "バグ: 誤った式のトークンです"

#: expr.c:595
msgid "`:' expected for conditional expression"
msgstr "条件式には `:' が予期されます"

#: expr.c:919
msgid "exponent less than 0"
msgstr "0より小さい指数部です"

#: expr.c:976
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "識別子は前置インクリメントまたは前置デクリメントが予期されます"

#: expr.c:1002
msgid "missing `)'"
msgstr "`)' がありません"

#: expr.c:1053 expr.c:1390
msgid "syntax error: operand expected"
msgstr "構文エラー: オペランドが予期されます"

#: expr.c:1392
msgid "syntax error: invalid arithmetic operator"
msgstr "構文エラー: 無効な計算演算子です"

#: expr.c:1416
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (エラーのあるトークンは \"%s\")"

#: expr.c:1474
msgid "invalid arithmetic base"
msgstr "無効な基底の数値です"

#: expr.c:1494
msgid "value too great for base"
msgstr "基底の値が大きすぎます"

#: expr.c:1543
#, c-format
msgid "%s: expression error\n"
msgstr "%s: 式のエラー\n"

#: general.c:62
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: 親ディレクトリにアクセスできません"

#: input.c:102 subst.c:5168
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "ファイル記述子(fd) %d を無遅延モードに再設定できません"

#: input.c:271
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "新規ファイル記述子(fd) %d を bash の入力として割り当てられません"

#: input.c:279
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: 新規 fd %d のバッファはすでに存在します"

#: jobs.c:471
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:893
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "実行中のジョブ %2$d で fork した pid %1$d が出現しました"

#: jobs.c:1012
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "プロセスグループ %2$ld のジョブ %1$d を削除しています"

#: jobs.c:1117
#, c-format
msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr "add_process: プロセス %5ld (%s) が the_pipeline にあります"

#: jobs.c:1120
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) はまだ存在しているとマークされています"

#: jobs.c:1435
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: そのような pid は存在しません"

#: jobs.c:1450
#, c-format
msgid "Signal %d"
msgstr "シグナル %d"

#: jobs.c:1464 jobs.c:1489
msgid "Done"
msgstr "終了"

#: jobs.c:1469 siglist.c:123
msgid "Stopped"
msgstr "停止"

#: jobs.c:1473
#, c-format
msgid "Stopped(%s)"
msgstr "停止 (%s)"

#: jobs.c:1477
msgid "Running"
msgstr "実行中"

#: jobs.c:1491
#, c-format
msgid "Done(%d)"
msgstr "終了(%d)"

#: jobs.c:1493
#, c-format
msgid "Exit %d"
msgstr "終了 %d"

#: jobs.c:1496
msgid "Unknown status"
msgstr "不明なステータス"

#: jobs.c:1583
#, c-format
msgid "(core dumped) "
msgstr "(コアダンプ) "

#: jobs.c:1602
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd: %s)"

#: jobs.c:1819
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "子プロセス setpgid (%ld から %ld)"

#: jobs.c:2138 nojobs.c:605
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: pid %ld はこのシェルの子プロセスではありません"

#: jobs.c:2385
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: プロセス %ld の記録がありません"

#: jobs.c:2694
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: ジョブ %d は停止しています"

#: jobs.c:2986
#, c-format
msgid "%s: job has terminated"
msgstr "%s: ジョブは終了しました"

#: jobs.c:2995
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: ジョブ %d はすでにバックグラウンドで動作しています"

#: jobs.c:3220
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: 不定のブロックを避けるために WNOHANG をオンにしました。"

#: jobs.c:3711
#, c-format
msgid "%s: line %d: "
msgstr "%s: %d 行: "

#: jobs.c:3725 nojobs.c:843
#, c-format
msgid " (core dumped)"
msgstr " (コアダンプ)"

#: jobs.c:3737 jobs.c:3750
#, c-format
msgid "(wd now: %s)\n"
msgstr "(wd now: %s)\n"

#: jobs.c:3782
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp が失敗しました"

#: jobs.c:3843
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: line discipline"

#: jobs.c:3853
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:3874 jobs.c:3883
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "端末プロセスグループを設定できません (%d)"

#: jobs.c:3888
msgid "no job control in this shell"
msgstr "このシェルではジョブ制御が無効になっています"

#: lib/malloc/malloc.c:296
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: 失敗したアサーション: %s\n"

#: lib/malloc/malloc.c:312
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: アサーション失敗\r\n"

#: lib/malloc/malloc.c:313
msgid "unknown"
msgstr "不明"

#: lib/malloc/malloc.c:801
msgid "malloc: block on free list clobbered"
msgstr "malloc: free ブロックリストが壊れています"

#: lib/malloc/malloc.c:878
msgid "free: called with already freed block argument"
msgstr "free: 既に free されたブロックを引数として呼び出されました"

#: lib/malloc/malloc.c:881
msgid "free: called with unallocated block argument"
msgstr "free: 未割当のブロックを引数として呼び出されました"

#: lib/malloc/malloc.c:900
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: アンダーフローを検出しました。 mh_nbytes が範囲外です"

#: lib/malloc/malloc.c:906
msgid "free: start and end chunk sizes differ"
msgstr "free: 開始と終了の塊の大きさが異なっています"

#: lib/malloc/malloc.c:1005
msgid "realloc: called with unallocated block argument"
msgstr "realloc: 未割当のブロックを引数として呼び出されました"

#: lib/malloc/malloc.c:1020
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: アンダーフローを検出しました。 mh_nbytes が範囲外です"

#: lib/malloc/malloc.c:1026
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: 開始と終了の塊の大きさが異なっています"

#: lib/malloc/table.c:194
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: FIND_ALLOC で割り当てテーブルがいっぱいです\n"

#: lib/malloc/table.c:203
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p 既にテーブル上では割り当てられています\n"

#: lib/malloc/table.c:256
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p テーブル上では既に解放されています\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "無効な基底"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: 不明なホストです"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: 無効なサービスです"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: ネットワークパス指定に誤りがあります"

#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr "ネットワーク操作はサポートされていません"

#: locale.c:200
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: ロケールを変更できません (%s)"

#: locale.c:202
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: ロケールを変更できません (%s): %s"

#: locale.c:259
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: ロケールを変更できません (%s)"

#: locale.c:261
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: ロケールを変更できません (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "メールが $_ にあります"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "新しいメールが $_ にあります"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "%s のメールは既読です\n"

#: make_cmd.c:323
msgid "syntax error: arithmetic expression required"
msgstr "構文エラー: 数値の式が必要です"

#: make_cmd.c:325
msgid "syntax error: `;' unexpected"
msgstr "構文エラー: 予期しない `;' です"

#: make_cmd.c:326
#, c-format
msgid "syntax error: `((%s))'"
msgstr "構文エラー: `((%s))'"

#: make_cmd.c:578
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: 誤った指定の種類 %d"

#: make_cmd.c:662
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"ヒアドキュメントの %d 行目でファイル終了 (EOF) に達しました (`%s' が必要)"

#: make_cmd.c:759
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: リダイレクト指定 `%d' は範囲外です"

#: parse.y:3278 parse.y:3561
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "対応する `%c' を探索中に予期しないファイル終了 (EOF) です"

#: parse.y:4170
msgid "unexpected EOF while looking for `]]'"
msgstr "`]]' を探索中に予期しないファイル終了 (EOF) です"

#: parse.y:4175
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "条件式に構文エラー: 予期しないトークン `%s' です"

#: parse.y:4179
msgid "syntax error in conditional expression"
msgstr "条件式に構文エラーがあります"

#: parse.y:4257
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "予期しないトークン `%s' です。`)' が予期されます"

#: parse.y:4261
msgid "expected `)'"
msgstr "`)' が予期されます"

#: parse.y:4289
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "条件単項演算子に予期しない引数 `%s' です"

#: parse.y:4293
msgid "unexpected argument to conditional unary operator"
msgstr "条件単項演算子に予期しない引数です"

#: parse.y:4339
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "`%s` は予期しないトークンです。条件二項演算子が予期されます"

#: parse.y:4343
msgid "conditional binary operator expected"
msgstr "条件二項演算子が予期されます"

#: parse.y:4365
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "条件二項演算子に予期しない引数 `%s' です"

#: parse.y:4369
msgid "unexpected argument to conditional binary operator"
msgstr "条件二項演算子に予期しない引数です"

#: parse.y:4380
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "条件コマンドに予期しないトークン `%c' があります"

#: parse.y:4383
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "条件コマンドに予期しないトークン `%s' があります"

#: parse.y:4387
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "条件コマンドに予期しないトークン %d があります"

#: parse.y:5737
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "予期しないトークン `%s' 周辺に構文エラーがあります"

#: parse.y:5755
#, c-format
msgid "syntax error near `%s'"
msgstr "`%s' 周辺に構文エラーがあります"

#: parse.y:5765
msgid "syntax error: unexpected end of file"
msgstr "構文エラー: 予期しないファイル終了 (EOF) です"

#: parse.y:5765
msgid "syntax error"
msgstr "構文エラー"

#: parse.y:5827
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "シェルから脱出するには \"%s\" を使用してください。\n"

#: parse.y:5989
msgid "unexpected EOF while looking for matching `)'"
msgstr "対応する `)' を探索中に予期しないファイル終了(EOF)です"

#: pcomplete.c:1094
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: 関数 `%s' が見つかりません"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:300
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: 誤った接続 `%d'"

#: print_cmd.c:373
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: 無効なファイル記述子です"

#: print_cmd.c:378
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: NULL ファイルポインタです"

#: print_cmd.c:382
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1518
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: `%c': 無効な書式文字です"

#: redir.c:123 redir.c:170
msgid "file descriptor out of range"
msgstr "ファイル記述子が範囲外です"

#: redir.c:177
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: 曖昧なリダイレクトです"

#: redir.c:181
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: 存在するファイルを上書きできません"

#: redir.c:186
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: 制限されています: 出力をリダイレクト出来ません"

#: redir.c:191
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "ヒアドキュメント用一時ファイルを作成できません: %s"

#: redir.c:195
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: ファイル記述子 (fd) を変数に設定することはできません"

#: redir.c:582
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "ネットワークが無効な場合 /dev/(tcp|udp)/host/port はサポートされません"

#: redir.c:861 redir.c:973 redir.c:1034 redir.c:1199
msgid "redirection error: cannot duplicate fd"
msgstr "リダイレクトエラー: ファイル記述子を複製できません"

#: shell.c:339
msgid "could not find /tmp, please create!"
msgstr "/tmp が見つかりません。作成してください!"

#: shell.c:343
msgid "/tmp must be a valid directory name"
msgstr "/tmp は有効なディレクトリ名でなければいけません"

#: shell.c:890
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: 無効なオプション"

#: shell.c:1682
msgid "I have no name!"
msgstr "私は名前がありません!"

#: shell.c:1827
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, バージョン %s-(%s)\n"

#: shell.c:1828
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"使用法:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"

#: shell.c:1830
msgid "GNU long options:\n"
msgstr "GNU 形式の長いオプション:\n"

#: shell.c:1834
msgid "Shell options:\n"
msgstr "シェルオプション:\n"

#: shell.c:1835
#, fuzzy
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD または -c command または -O shopt_option\t\t(起動時のみ)\n"

#: shell.c:1850
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s または -o option\n"

#: shell.c:1856
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"シェルオプションの詳細については `%s -c \"help set\"'と入力してください。\n"

#: shell.c:1857
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "シェル組み込みコマンドについては `%s -c help' と入力してください。\n"

#: shell.c:1858
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "バグ報告をする場合は `bashbug' コマンドを使用してください。\n"

#: sig.c:691
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: 無効な操作です"

#: siglist.c:48
msgid "Bogus signal"
msgstr "悪いシグナル"

#: siglist.c:51
msgid "Hangup"
msgstr "停止"

#: siglist.c:55
msgid "Interrupt"
msgstr "割り込み"

#: siglist.c:59
msgid "Quit"
msgstr "終了"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "不正な指定"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "BPT trace/trap"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "ABORT 指定"

#: siglist.c:79
msgid "EMT instruction"
msgstr "EMT 指定"

#: siglist.c:83
msgid "Floating point exception"
msgstr "浮動小数点例外"

#: siglist.c:87
msgid "Killed"
msgstr "Killed"

#: siglist.c:91
msgid "Bus error"
msgstr "バスエラー"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "セグメンテーションフォルト"

#: siglist.c:99
msgid "Bad system call"
msgstr "誤ったシステムコール"

#: siglist.c:103
msgid "Broken pipe"
msgstr "パイプが切れました"

#: siglist.c:107
msgid "Alarm clock"
msgstr "アラーム時計"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminated"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "急ぎの IO 状態"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "停止 (シグナル)"

#: siglist.c:127
msgid "Continue"
msgstr "続行"

#: siglist.c:135
msgid "Child death or stop"
msgstr "子プロセスの死亡または停止 "

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "停止 (tty 入力)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "停止 (tty 出力)"

#: siglist.c:147
msgid "I/O ready"
msgstr "I/O 用意ができています"

#: siglist.c:151
msgid "CPU limit"
msgstr "CPU limit"

#: siglist.c:155
msgid "File limit"
msgstr "ファイル limit"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "警報 (仮想)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "警報 (プロファイル)"

#: siglist.c:167
msgid "Window changed"
msgstr "ウィンドウが変更されました"

#: siglist.c:171
msgid "Record lock"
msgstr "記録のロック"

#: siglist.c:175
msgid "User signal 1"
msgstr "ユーザシグナル 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "ユーザシグナル 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "HFT 未決の入力データ"

#: siglist.c:187
msgid "power failure imminent"
msgstr "電源故障の危険"

#: siglist.c:191
msgid "system crash imminent"
msgstr "システムクラッシュの危険"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "プロセスを別のCPUに移動"

#: siglist.c:199
msgid "programming error"
msgstr "プログラミングエラー"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "HFT monitorモードが与えられました"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "HFT monitorモードが奪われました"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFT サウンドシーケンスが完了しました"

#: siglist.c:215
msgid "Information request"
msgstr "情報要求"

#: siglist.c:223
msgid "Unknown Signal #"
msgstr "不明なシグナル番号"

#: siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "不明なシグナル番号 %d"

#: subst.c:1362 subst.c:1520
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "誤った代入: 閉じる `%s' が %s に存在しません"

#: subst.c:2847
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: リストを配列要素に割り当てできません"

#: subst.c:5065 subst.c:5081
msgid "cannot make pipe for process substitution"
msgstr "プロセス代入ではパイプを作成できません"

#: subst.c:5113
msgid "cannot make child for process substitution"
msgstr "プロセス代入では子プロセスを作成できません"

#: subst.c:5158
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "名前付きパイプ %s を読み込み用に開けません"

#: subst.c:5160
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "名前付きパイプ %s を書き込み用に開けません"

#: subst.c:5178
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "名前付きパイプ %s をファイル記述子(fd) %d として複製できません"

#: subst.c:5376
msgid "cannot make pipe for command substitution"
msgstr "コマンド代入ではパイプを作成できません"

#: subst.c:5414
msgid "cannot make child for command substitution"
msgstr "コマンド代入では子プロセスを作成できません"

#: subst.c:5433
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: パイプを fd 1 として複製できません"

#: subst.c:5837 subst.c:8050
#, fuzzy, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: %s: トレースファイル記述子として無効な値です"

#: subst.c:6048
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: パラメータが null または設定されていません"

#: subst.c:6320 subst.c:6335
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: substring expression < 0"

#: subst.c:7506
#, c-format
msgid "%s: bad substitution"
msgstr "%s: 誤った代入です"

#: subst.c:7583
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: この方法で割当はできません"

#: subst.c:7917
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr "将来のバージョンのシェルでは強制的に数値代入として評価されます"

#: subst.c:8421
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "誤った代入: %s に閉じる \"`\" がありません"

#: subst.c:9322
#, c-format
msgid "no match: %s"
msgstr "一致しません: %s"

#: test.c:147
msgid "argument expected"
msgstr "引数が予期されます"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: 整数の式が予期されます"

#: test.c:264
msgid "`)' expected"
msgstr "`)' が予期されます"

#: test.c:266
#, c-format
msgid "`)' expected, found %s"
msgstr "`)' が予期されますが、見つかったのは %s です"

#: test.c:281 test.c:742 test.c:745
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: 単項演算子が予期されます"

#: test.c:468 test.c:785
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: 二項演算子が予期されます"

#: test.c:860
msgid "missing `]'"
msgstr "`]'がありません"

#: trap.c:217
msgid "invalid signal number"
msgstr "無効なシグナル番号"

#: trap.c:371
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: trap_list[%d] に誤った値があります: %p"

#: trap.c:375
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"run_pending_traps: シグナルハンドラーは SIG_DFLです。, %d (%s) を自身に再送し"
"ます。"

#: trap.c:428
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: 誤ったシグナル %d"

#: variables.c:382
#, c-format
msgid "error importing function definition for `%s'"
msgstr "`%s' の関数定義をインポート中にエラーが発生しました"

#: variables.c:780
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "シェルレベル (%d) は高すぎます。1に再設定されました"

#: variables.c:1865
#, c-format
msgid "%s: circular name reference"
msgstr ""

#: variables.c:2228
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: 現在のスコープは関数コンテキストではありません"

#: variables.c:2247
#, fuzzy, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: ファイル記述子 (fd) を変数に設定することはできません"

#: variables.c:3646
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: 現在のスコープは関数コンテキストではありません"

#: variables.c:3891
#, c-format
msgid "%s has null exportstr"
msgstr "%s は null の exportstr を持っています"

#: variables.c:3896 variables.c:3905
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "%2$s に対する exportstr で %1$d は無効な文字です"

#: variables.c:3911
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "%s に対する exportstr に `=' がありません"

#: variables.c:4344
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"pop_var_context: shell_variables の先頭です。関数コンテキストではありません"

#: variables.c:4357
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: global_variables コンテキストではありません"

#: variables.c:4431
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: shell_variables の先頭です。一時環境スコープではありません"

#: variables.c:5257
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: ファイルとして開くことができません"

#: variables.c:5262
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: トレースファイル記述子として無効な値です"

#: variables.c:5307
#, fuzzy, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s が範囲外です"

#: version.c:46
#, fuzzy
msgid "Copyright (C) 2013 Free Software Foundation, Inc."
msgstr "Copyright (C) 2011 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"ライセンス GPLv3+: GNU GPL バージョン 3 またはそれ以降 <http://gnu.org/"
"licenses/gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, バージョン %s (%s)\n"

#: version.c:91 version2.c:91
#, fuzzy
msgid "This is free software; you are free to change and redistribute it."
msgstr "This is free software; you are free to change and redistribute it.\n"

#: version.c:92 version2.c:92
#, fuzzy
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "There is NO WARRANTY, to the extent permitted by law.\n"

#: version2.c:46
#, fuzzy
msgid "Copyright (C) 2012 Free Software Foundation, Inc."
msgstr "Copyright (C) 2011 Free Software Foundation, Inc."

#: xmalloc.c:91
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %lu バイトを割当できません (%lu バイトを割当済み)"

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: %lu バイトを割当できません"

#: xmalloc.c:163
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: %lu バイトを割当できません (%lu バイトを割当済み)"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: %lu バイトを割当できません"

#: builtins.c:43
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [name[=value] ... ]"

#: builtins.c:47
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] name [name ...]"

#: builtins.c:51
#, fuzzy
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function または readline-command]"

#: builtins.c:54
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:56
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:58
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [shell-builtin [arg ...]]"

#: builtins.c:61
msgid "caller [expr]"
msgstr "caller [expr]"

#: builtins.c:64
#, fuzzy
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]]] [dir]"

#: builtins.c:66
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:68
msgid ":"
msgstr ":"

#: builtins.c:70
msgid "true"
msgstr "true"

#: builtins.c:72
msgid "false"
msgstr "false"

#: builtins.c:74
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] command [arg ...]"

#: builtins.c:76
#, fuzzy
msgid "declare [-aAfFgilnrtux] [-p] [name[=value] ...]"
msgstr "declare [-aAfFgilrtux] [-p] [name[=value] ...]"

#: builtins.c:78
msgid "typeset [-aAfFgilrtux] [-p] name[=value] ..."
msgstr "typeset [-aAfFgilrtux] [-p] name[=value] ..."

#: builtins.c:80
msgid "local [option] name[=value] ..."
msgstr "local [option] name[=value] ..."

#: builtins.c:83
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:87
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:90
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f filename] [name ...]"

#: builtins.c:92
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:94
msgid "getopts optstring name [arg]"
msgstr "getopts optstring name [arg]"

#: builtins.c:96
msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"

#: builtins.c:98
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:100
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:103
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e ename] [-lnr] [first] [last] または fc -s [pat=rep] [command]"

#: builtins.c:107
msgid "fg [job_spec]"
msgstr "fg [job_spec]"

#: builtins.c:111
msgid "bg [job_spec ...]"
msgstr "bg [job_spec ...]"

#: builtins.c:114
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p pathname] [-dt] [name ...]"

#: builtins.c:117
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [pattern ...]"

#: builtins.c:121
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d offset] [n] または history -anrw [filename] または history -"
"ps arg [arg...]"

#: builtins.c:125
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [jobspec ...] または jobs -x command [args]"

#: builtins.c:129
msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [-h] [-ar] [jobspec ...]"

#: builtins.c:132
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... または kill -l "
"[sigspec]"

#: builtins.c:134
msgid "let arg [arg ...]"
msgstr "let 引数 [引数 ...]"

#: builtins.c:136
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"

#: builtins.c:138
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:140
msgid "set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]"

#: builtins.c:142
#, fuzzy
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [name ...]"

#: builtins.c:144
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [name[=value] ...] または export -p"

#: builtins.c:146
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [name[=value] ...] または readonly -p"

#: builtins.c:148
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:150
msgid "source filename [arguments]"
msgstr "source filename [arguments]"

#: builtins.c:152
msgid ". filename [arguments]"
msgstr ". filename [arguments]"

#: builtins.c:155
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:158
msgid "test [expr]"
msgstr "test [expr]"

#: builtins.c:160
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:162
msgid "times"
msgstr "times"

#: builtins.c:164
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] signal_spec ...]"

#: builtins.c:166
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] name [name ...]"

#: builtins.c:169
#, fuzzy
msgid "ulimit [-SHabcdefilmnpqrstuvxT] [limit]"
msgstr "ulimit [-SHacdefilmnpqrstuvx] [limit]"

#: builtins.c:172
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [mode]"

#: builtins.c:175
#, fuzzy
msgid "wait [-n] [id ...]"
msgstr "wait [id]"

#: builtins.c:179
#, fuzzy
msgid "wait [pid ...]"
msgstr "wait [pid]"

#: builtins.c:182
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NAME [in WORDS ... ] ; do COMMANDS; done"

#: builtins.c:184
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do COMMANDS; done"

#: builtins.c:186
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NAME [in WORDS ... ;] do COMMANDS; done"

#: builtins.c:188
msgid "time [-p] pipeline"
msgstr "time [-p] pipeline"

#: builtins.c:190
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"

#: builtins.c:192
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"

#: builtins.c:194
msgid "while COMMANDS; do COMMANDS; done"
msgstr "while COMMANDS; do COMMANDS; done"

#: builtins.c:196
msgid "until COMMANDS; do COMMANDS; done"
msgstr "until COMMANDS; do COMMANDS; done"

#: builtins.c:198
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NAME] command [redirections]"

#: builtins.c:200
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function name { COMMANDS ; } または name () { COMMANDS ; }"

#: builtins.c:202
msgid "{ COMMANDS ; }"
msgstr "{ COMMANDS ; }"

#: builtins.c:204
msgid "job_spec [&]"
msgstr "job_spec [&]"

#: builtins.c:206
msgid "(( expression ))"
msgstr "(( expression ))"

#: builtins.c:208
msgid "[[ expression ]]"
msgstr "[[ expression ]]"

#: builtins.c:210
msgid "variables - Names and meanings of some shell variables"
msgstr "変数 - 変数の名前とその意味"

#: builtins.c:213
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir]"

#: builtins.c:217
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:221
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:224
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [optname ...]"

#: builtins.c:226
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] format [arguments]"

#: builtins.c:229
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-"
"W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-"
"W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"

#: builtins.c:233
msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"

#: builtins.c:237
msgid "compopt [-o|+o option] [-DE] [name ...]"
msgstr "compopt [-o|+o option] [-DE] [name ...]"

#: builtins.c:240
msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"

#: builtins.c:242
msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"

#: builtins.c:254
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"エイリアスを定義または表示します。\n"
"    \n"
"    引数がない場合、`alias` は再使用可能なエイリアス一覧を `alias 名前=値'\n"
"    形式で標準出力に表示します。\n"
"    \n"
"    そうでなければ、与えられた名前と値でエイリアスを定義します。値の後続に空"
"白\n"
"    が存在する場合は次の語はエイリアス展開時にエイリアス代入対象として確認さ"
"れ\n"
"    ます。\n"
"\n"
"    オプション:\n"
"      -p\tすべての定義されたエイリアスを再利用可能な形式で表示します\n"
"    \n"
"    終了ステータス:\n"
"    alias は与えられた名前でエイリアスが定義されなかった場合を除き true を返"
"します。"

#: builtins.c:276
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"定義されたエイリアス一覧から各名前のエイリアスを削除します。\n"
"    \n"
"    Options:\n"
"      -a\tすべてのエイリアス定義を削除します。\n"
"    \n"
"    名前がエイリアスに存在しない場合を除き true を返します。"

#: builtins.c:289
#, fuzzy
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X\t\t     List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Readline のキーバインディングと変数を設定します。\n"
"    \n"
"    キーシーケンスを Readline 関数またはマクロに関連付けを行うか、Readline\n"
"    変数を設定します。オプションが無い引数の構文は ~/.inputrc の構文と\n"
"    同様です。しかし、単一の引数として与えなければなりません。\n"
"    例: bind '\"\\C-x\\C-r\": re-read-init-file'\n"
"    \n"
"    オプション:\n"
"      -m  keymap         このコマンドの間のキーマップとして KEYMAP を使用す"
"る。\n"
"                         利用可能なキーマップは emacs, emacs-standard, emacs-"
"meta,\n"
"                          emacs-ctlx, vi, vi-move, vi-command, および vi-"
"insert。\n"
"      -l                 関数名一覧を表示します。\n"
"      -P                 関数名およびキーバインディング一覧を表示します。\n"
"      -p                 関数名とキーバインディングを入力として再利用可能な\n"
"                         形式で一覧表示します。\n"
"      -S                 マクロを起動するキーシーケンスとその値を一覧表示す"
"る\n"
"      -s                 入力として再利用可能な形式で、マクロを起動する\n"
"                         キーシーケンスとその値を一覧表示する\n"
"      -V                 変数名と値の一覧を表示します。\n"
"      -v                 変数名と値を入力として再利用可能な形式で一覧\n"
"                         表示します。\n"
"      -q  function-name  関数名がどのキーによって起動されるか探索します\n"
"      -u  function-name  関数名にバインドされたすべてのキーを解除します。\n"
"      -r  keyseq         KEYSEQ に対するバインドを解除します。\n"
"      -f  filename       FILENAME からキーバインドを読み込みます。\n"
"      -x  keyseq:shell-command\tKEYSEQ が入力された時に SHELL-COMMAND \n"
"    \t\t\t\tが実行されるようにします。\n"
"    \n"
"    終了ステータス:\n"
"    bind は解釈できないオプションが渡された場合およびエラーが発生した場合\n"
"    を除き 0 を返します。"

#: builtins.c:328
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"for、 while、または until ループを脱出します。\n"
"    \n"
"    FOR、 WHILE、または UNTIL ループを脱出します  もし N が指定されている場"
"合、\n"
"    N階層のループを終了します。\n"
"    \n"
"    終了ステータス:\n"
"    N が1未満の場合を除き、終了ステータスは 0 です。"

#: builtins.c:340
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"for, while, または until ループを再開します。\n"
"    \n"
"    FOR, WHILE または UNTIL ループの次の繰り返しを再開します。\n"
"    もし N が指定された場合、N 階層のループを再開します。\n"
"    \n"
"    終了ステータス:\n"
"    N  が1未満の場合を除き、終了ステータスは 0 です。"

#: builtins.c:352
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""
"シェル組み込みコマンドを実行します。\n"
"    \n"
"    コマンドを検索しないでシェル組み込みコマンドを ARG をつけて実行し\n"
"    ます。これはシェル組み込みコマンドをシェル関数として実装するが、関数\n"
"    内で組み込みコマンドを実行する必要がある場合に役に立ちます。\n"
"    \n"
"    終了ステータス:\n"
"    シェル組み込みコマンドの終了ステータスを返します。シェル組み込みコマ\n"
"    ンドが無い場合は false を返します。"

#: builtins.c:367
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"現在のサブルーチン呼び出しのコンテキストを返します。\n"
"    \n"
"    EXPR が無い場合 \"$line $filename\" を返します。  EXPR がある場合、\n"
"    \"$line $subroutine $filename\" を返します。この追加の情報はスタックト"
"レース\n"
"    を提供する時に利用します。\n"
"    \n"
"    EXPR の値は現在のフレームに戻るまでに何回フレームが呼び出されているかを\n"
"    意味します。最上位のフレームは 0 です。\n"
"    \n"
"    終了ステータス:\n"
"    シェルが関数を実行できないか式 EXPR が無効な場合を除き 0 を返します。"

#: builtins.c:385
#, fuzzy
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"        -L\tforce symbolic links to be followed: resolve symbolic links in\n"
"    \tDIR after processing instances of `..'\n"
"        -P\tuse the physical directory structure without following symbolic\n"
"    \tlinks: resolve symbolic links in DIR before processing instances\n"
"    \tof `..'\n"
"        -e\tif the -P option is supplied, and the current working directory\n"
"    \tcannot be determined successfully, exit with a non-zero status\n"
"        -@  on systems that support it, present a file with extended "
"attributes\n"
"            as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"シェルの作業ディレクトリを変更します。\n"
"    \n"
"    カレントディレクトリを DIR へ変更します。DIR のデフォルトは HOME シェル\n"
"    変数の値です。\n"
"    \n"
"    変数 CDPATH は DIR を含んでいる検索パスを定義します。CDPATH にはコロン"
"(:)\n"
"    で区切られた代替ディレクトリ名を指定します。\n"
"    NULL のディレクトリ名はカレントディレクトリと同義です。 DIR が\n"
"    スラッシュ (/) から始まる場合は CDPATH は使用されません。\n"
"\n"
"    ディレクトリが見つからなく、かつ `cdabl_vars' シェルオプションが設定され"
"て\n"
"    いる場合、引数は変数名として扱われます。その変数に値がある場合、その値"
"が\n"
"    DIR として扱われます。\n"
"    \n"
"    オプション:\n"
"        -L\tシンボリックリンクを強制的にたどります\n"
"        -P\tシンボリックリンクをたどらず物理構造を利用します\n"
"        -e\t-P オプションが与えられ、かつ、現在の作業ディレクトリが正しく\n"
"    \t決定できない場合、終了ステータスが 0 以外で終了します\n"
"    \n"
"    デフォルトでは `-L' が指定された場合と同様シンボリックリンクをたどりま"
"す\n"
"    \n"
"    終了ステータス:\n"
"    ディレクトリを変更した場合、および -P が使用されている時に $PWD が正し"
"く\n"
"    設定された場合は 0、それ以外は 0 以外の値です。"

#: builtins.c:422
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"カレントディレクトリの名前を表示します。\n"
"    \n"
"    オプション:\n"
"      -L\t$PWD がカレントディレクトリの名前を指している場合は $PWD\n"
"    \tを表示する\n"
"      -P\tシンボリックリンクを辿った物理的なディレクトリを表示する\n"
"    \n"
"    デフォルトでは `pwd' は `-L' が指定されたように動作します。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションまたはカレントディレクトリを読み込めない場合を除き\n"
"    0を返します。"

#: builtins.c:439
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"何もしないコマンド\n"
"    \n"
"    何も効果がありません。コマンドは何も行いません\n"
"    \n"
"    終了ステータス:\n"
"    常に成功です。"

#: builtins.c:450
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"結果として成功を返します。\n"
"    \n"
"    終了ステータス:\n"
"    常に成功です。"

#: builtins.c:459
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"結果として失敗を返します。\n"
"    \n"
"    終了ステータス:\n"
"    常に失敗です。"

#: builtins.c:468
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"単純なコマンドを実行するかコマンドに関する情報を表示します。\n"
"    \n"
"    シェル関数の探索を抑止して COMMAND を引数 ARGS で実行します。または\n"
"    指定した COMMANDs の情報を表示します。シェル関数と同じ名前のコマンド\n"
"    がディスク上に存在する時に使用します。\n"
"    \n"
"    オプション:\n"
"      -p\t全ての標準ユーティリティが見つかると保証される PATH を\n"
"    \tデフォルトの値として使用する\n"
"      -v\t`type'組み込み関数と同様に COMMAND の説明を表示する\n"
"      -V\tCOMMAND に対してより冗長な説明を表示する\n"
"    \n"
"    終了ステータス:\n"
"    COMMAND の終了ステータスを返します。または COMMAND が見つからない時に失敗"
"を返します。"

#: builtins.c:487
#, fuzzy
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \tignored\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert NAMEs to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert NAMEs to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"変数の値および属性を設定します。\n"
"    \n"
"    変数を宣言し、それに属性を与えます。NAME を指定しない場合\n"
"    すべての変数に関する属性と値を表示します。\n"
"    \n"
"    オプション:\n"
"      -f\t関数名と関数定義になるように動作と表示を制限する\n"
"      -F\t関数名のみ表示するように制限する (デバッグ中は行番号と\n"
"    \tソースファイルも追加される)\n"
"      -g\tシェル関数内で使用された時に大域変数を作成する。それ以\n"
"    \t外の場合は無視される\n"
"      -p\t各 NAME の属性と値を表示する\n"
"    \n"
"    属性を設定するオプション:\n"
"      -a\tNAME をインデックス型配列にする(サポートされている場合)\n"
"      -A\tNAME を連想配列にする(サポートされている場合)\n"
"      -i\tNAME に`整数型'の属性を設定する\n"
"      -l\tNAME の設定時に値を小文字に変換する\n"
"      -r\tNAME を読み取り専用にする\n"
"      -t\tNAME に `trace' 属性を設定する\n"
"      -u\tNAME 設定時に値を大文字に設定する\n"
"      -x\tNAME をエクスポートする\n"
"    \n"
"    `-' の代わりに `+' を使用すると与えられた属性を無効にします。\n"
"    \n"
"    整数属性を与えられた変数は値を割り当てられた時に、数値として評価され\n"
"    ます。(`let' コマンド参照してください。)\n"
"    \n"
"    関数内で使用された場合は `local' コマンドを使用した時と同様に "
"`declare' \n"
"    は NAME をローカル変数にします。`-g' オプションはこの動作を抑止します。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられたかエラーが発生しない限り成功を返します。"

#: builtins.c:527
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""
"変数の値および属性を設定します。\n"
"    \n"
"    旧式です。`help declare'を参照してください。"

#: builtins.c:535
#, fuzzy
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"ローカル変数を定義します。\n"
"    \n"
"    NAME という名前のローカル変数を定義し値を VALUE に設定します。"
"`declare'と\n"
"    同じオプションを受け付けます。\n"
"    \n"
"    ローカル変数はシェル関数の中でのみ使用できます。宣言された関数の中および"
"そこ\n"
"    から呼び出された関数のみで参照できます。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられる、エラーが発生する、またはシェルが関数を実行"
"できない\n"
"    場合を除き成功を返します。"

#: builtins.c:552
#, fuzzy
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \tcan be one or two hex digits\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"引数を標準出力に書き出します。\n"
"    \n"
"    引数 ARG を最後に改行を加えて標準出力に表示します。\n"
"    \n"
"    オプション:\n"
"      -n\t最後に改行を加えない\n"
"      -e\t下記に示すバックスラッシュエスケープの解釈を有効にする\n"
"      -E\tバックスラッシュエスケープの解釈を明示的に無効にする\n"
"    \n"
"    `echo' では下記のバックスラッシュエスケープ文字を解釈します:\n"
"      \\a\tアラート (bell)\n"
"      \\b\tバックスペース\n"
"      \\c\t以降の出力を抑止\n"
"      \\e\tエスケープ文字\n"
"      \\f\tフォームフィード\n"
"      \\n\t改行\n"
"      \\r\tキャリッジリターン\n"
"      \\t\t水平タブ\n"
"      \\v\t垂直タブ\n"
"      \\\\\tバックスラッシュ\n"
"      \\0nnn\tASCII コードが NNN (8進数) の文字。 NNN は0から3個の8進数字\n"
"      \\xHH\t値が HH (16進数) の8ビット文字。HH は 1 または2個の16進数字\n"
"    \n"
"    終了ステータス:\n"
"    書き込みエラーが発生しない限り成功を返します。"

#: builtins.c:588
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"引数を標準出力に書き出します。\n"
"    \n"
"    引数 ARG を最後に改行を加えて標準出力に表示します。\n"
"    \n"
"    オプション:\n"
"      -n\t最後に改行を加えない\n"
"    \n"
"    終了ステータス:\n"
"    書き込みエラーが発生しない限り成功を返します。"

#: builtins.c:603
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"シェル組み込み関数を有効または無効にします。\n"
"    \n"
"    シェル組み込み関数を有効または無効にします。シェル組み込み関数を無効にす"
"ると\n"
"    ディスク上に存在するシェル組み込み関数と同じ名前のコマンドをフルパスを指"
"定す\n"
"    ることなく実行することが出来ます。\n"
"    \n"
"    オプション:\n"
"      -a\t組み込み関数の一覧をそれぞれが有効か否かを含めて表示します\n"
"      -n\tNAME を無効にするか、または無効な組み込み関数一覧を表示します\n"
"      -p\t組み込み関数一覧を再利用可能な形式で表示します\n"
"      -s\tPosix で定義されている組み込み関数のみ表示します\n"
"    \n"
"    動的ロードを制御するオプション:\n"
"      -f\t共有オブジェクト FILENAME から組み込み関数 NAME を読み込みます\n"
"      -d\t-f で読み込まれた組み込み関数を削除します\n"
"    \n"
"    オプション無しで起動された場合、各 NAME は有効になります。\n"
"    \n"
"    $PATH 上に存在する `test' をシェル組み込み関数の代わりに利用する場合は\n"
"    `enable -n test'と入力してください。\n"
"    \n"
"    終了ステータス:\n"
"    NAME が組み込み関数ではないかエラーが発生しない限り成功を返します。"

#: builtins.c:631
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"引数をシェルコマンドとして実行します。\n"
"    \n"
"    引数を一つの文字列に連結し、その結果をシェルへの入力として使用し、\n"
"    その結果をコマンドとして実行します。\n"
"    \n"
"    終了ステータス:\n"
"    コマンドの終了ステータスを返します。コマンドが null の場合は成功を\n"
"    返します。"

#: builtins.c:643
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"オプション引数を解析します。\n"
"    \n"
"    getopts は位置パラメーターをオプションとして解析する際にシェルによっ\n"
"    て使用される手続です。\n"
"    \n"
"    OPTSTRING には認識されるオプションの文字が含まれます。文字の後に\n"
"    コロン(:)が続く場合は、オプションは空白文字でオプションから区切\n"
"    られた引数を持つと予期されます。\n"
"    \n"
"    getopts は起動されるたびに、次のオプションをシェル変数 $name に保存\n"
"    します。name が存在しない場合は初期化されます。そして処理する必要が\n"
"    ある次の引数の位置をシェル変数 OPTIND に保存します。OPTIND はシェル\n"
"    またはシェルスクリプトが起動するたびに 1 に初期化されます。オプショ\n"
"    ンに引数が要求される場合、getopt は引数をシェル変数 OPTARG に保存し\n"
"    ます。\n"
"    \n"
"    getopts はエラーを2つの方法のいずれかで報告します。OPTSTRINGの最初\n"
"    の文字がコロン (:) の場合、getopts はサイレントエラー報告を使用し\n"
"    ます。このモードではエラーメッセージは表示されません。無効なオプシ\n"
"    ョンを見つけた時、 getopts はオプションの文字を OPTARG に設定しま\n"
"    す。必要なオプション引数が見つからない場合は、getopts は NAME に\n"
"    ':' を設定し、OPTARG にオプションの文字を設定します。getopts が\n"
"    サイレントモードで無い場合、無効なオプションを見つけた時、getopts \n"
"    は NAME に '?' を設定し、OPTARG を未定義状態にします。そして\n"
"    診断メッセージを表示します。\n"
"    \n"
"    シェル変数 OPTERR の値が 0 の場合、getopts は OPTSTRING の最初が\n"
"    コロン (:) か否かにかかわらずエラーメッセージの表示を抑止します。\n"
"    OPTERR のデフォルト値は 1 です。\n"
"    \n"
"    getopts では通常位置パラメーター ($0 - $9) を解析します。しかし\n"
"    他の引数が与えられた場合、それらが解析されます。\n"
"    \n"
"    終了ステータス:\n"
"    オプションが見つかった場合に成功を返します。オプションの終わり\n"
"    に到達するかエラーが発生した時に失敗を返します。"

#: builtins.c:685
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"シェルを与えられたコマンドで置換します。\n"
"    \n"
"    指定したプログラムでシェルを置換して COMMAND を実行します。ARGUMENTS は\n"
"    COMMAND の引数となります。もし COMMAND が指定されない場合は、現在のシェ"
"ル\n"
"    に対する全てのリダイレクトが行われます。\n"
"    \n"
"    オプション:\n"
"      -a name\tNAME を COMMAND の 0 番目の引数として与えます\n"
"      -c\t\tCOMMAND を環境変数なしで実行します\n"
"      -l\t\tdash(-) を COMMAND の 0 番目の引数とします\n"
"    \n"
"    もしコマンドが実行できない場合、非対話的なシェルは終了し、対話的なシェル"
"は\n"
"    オプション `execfail' が設定されます。\n"
"    \n"
"    終了ステータス:\n"
"    COMMAND が見つからないかリダイレクトエラーが発生しない限り成功を返しま"
"す。"

#: builtins.c:706
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"シェルを終了します。\n"
"    \n"
"    終了ステータス N でシェルを終了します。 N を指定しない場合は\n"
"    最後に実行したコマンドの終了ステータスになります。"

#: builtins.c:715
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"ログインシェルを終了します。\n"
"    \n"
"    終了ステータス N でログインシェルを終了します。実行したのがログインシェ"
"ル\n"
"    内で無い場合はエラーを返します。"

#: builtins.c:725
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"ヒストリ一覧からコマンドを表示または実行します。\n"
"    \n"
"    fc はヒストリ一覧を表示または編集してコマンドを再実行するために使用しま"
"す。\n"
"    FIRST および LAST は範囲を指定する数値です。FIRST は文字列を指定すること"
"も\n"
"    できます。その場合はその文字列で始まる直近に実行したコマンドを表しま"
"す。\n"
"    \n"
"    オプション:\n"
"      -e ENAME\t使用するエディタを選択します。デフォルトは FCEDIT で、次は "
"EDITOR、\n"
"     \t\tそして vi の順です。\n"
"      -l \t編集ではなく行を一覧表示します\n"
"      -n\t一覧表示時に行番号を表示しません\n"
"      -r\t行を逆順にします (最新のコマンドを最初にする)\n"
"    \n"
"    `fc -s [pat=rep ...] [command]' 形式を使用すると、COMMAND は\n"
"    OLD=NEW の置換が行われた後に再実行されます。\n"
"    \n"
"    これを使った使いやすいエイリアスは r='fc -s' です。これで `r cc' を実行す"
"る\n"
"    と最後に実行した cc で始まるコマンドが実行されます。`r' で直前のコマンド"
"が\n"
"    実行されます。\n"
"    \n"
"    終了ステータス:\n"
"    実行したコマンドのステータスまたは成功が帰ります。エラーが発生した場合は "
"0 \n"
"    以外の値になります。"

#: builtins.c:755
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"ジョブをフォアグランドにします。\n"
"    \n"
"    JOB_SPEC で識別されたジョブをフォアグランドにして、現在のジョブにしま"
"す。\n"
"    もし JOB_SPEC が存在しない場合、シェルが現在のレントジョブとして考えてい"
"る\n"
"    ものが利用されます。\n"
"    \n"
"    \n"
"    終了ステータス:\n"
"    フォアグラウンドになったコマンドのステータスを返します。または、エラー"
"が\n"
"    発生した時に失敗を返します。"

#: builtins.c:770
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"ジョブをバックグラウンドにします。\n"
"    \n"
"    JOB_SPEC で識別されるジョブを `&' と共に始めた時のようにバックグラウンド"
"に\n"
"    します。もし JOB_SPEC が存在しない場合、シェルが現在のジョブとして考えて"
"い\n"
"    るものが利用されます。\n"
"    \n"
"    終了ステータス:\n"
"    ジョブ制御が有効になっていないかエラーが発生しない限り成功を返します。"

#: builtins.c:784
#, fuzzy
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\t\tforget the remembered location of each NAME\n"
"      -l\t\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\t\tforget all remembered locations\n"
"      -t\t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"プログラムの位置を記憶または表示します。\n"
"    \n"
"    各コマンド NAME のフルパスを決定し記憶します。もし引数が与えられなかった"
"場合、\n"
"    記憶しているコマンドの情報が表示されます。\n"
"    \n"
"    オプション:\n"
"      -d\t\t各 NAME に対して記憶している情報を消去します\n"
"      -l\t\t入力として再可能な形式で表示します\n"
"      -p pathname\tNAME のフルパス名として PATHNAME を使用します\n"
"      -r\t\t全ての記憶している位置情報を消去します\n"
"      -t\t\t各 NAME に対して記憶している位置を表示します。複数の NAME\n"
"    \t\tが与えられた場合、位置を表示する前に対象となる NAME を表示します。\n"
"    引数:\n"
"      NAME\t\t各 NAME は $PATH の中を探索され、記録されたコマンド一覧に\n"
"    \t\t追加されます。\n"
"    \n"
"    終了ステータス:\n"
"    NAME が見つからないか、無効なオプションが与えられない限り成功を返します。"

#: builtins.c:809
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"組み込みコマンドの情報を表示します。\n"
"    \n"
"    組み込みコマンドに関する簡潔な要約を表示します。もし PATTERN が\n"
"    指定された場合は、PATTERN に一致する全てのコマンドに対する詳細な\n"
"    ヘルプを表示します。それ以外はヘルプトピックを表示します。\n"
"    \n"
"    オプション:\n"
"      -d\t各ヘルプトピックに対して短い説明を出力します\n"
"      -m\t使用法を擬似的な man ページ形式で表示します\n"
"      -s\t一致した各トピックに対して簡単な使用法のみを表示します\n"
"    \tPATTERN\n"
"    \n"
"    引数:\n"
"      PATTERN\tヘルプトピックを指定するパターン\n"
"    \n"
"    終了ステータス:\n"
"    PATTERN が見つからないか無効なオプションが与えられない限り成功を返しま"
"す。"

#: builtins.c:833
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"ヒストリ一覧を表示または操作します。\n"
"    \n"
"    行番号をつけてヒストリを表示します。操作した各項目には前に`*'が付きま"
"す。\n"
"    引数 N がある場合は最後の N 個の項目のみを表示します。\n"
"    \n"
"    オプション:\n"
"      -c\tヒストリ一覧から全ての項目を削除します。\n"
"      -d offset\tOFFSET 番目のヒストリ項目を削除します。\n"
"    \n"
"      -a\tこのセッションからヒストリファイルに行を追加します\n"
"      -n\tヒストリファイルからまだ読み込まれていない行を全て読み込みます\n"
"      -r\tヒストリファイルを読み込み、内容をヒストリ一覧に追加します\n"
"      -w\t現在のヒストリをヒストリファイルに書き込みます。そしてそれらを\n"
"    \tヒストリ一覧に追加します\n"
"    \n"
"      -p\t各 ARG に対してヒストリ展開を実行し、結果をヒストリ一覧に追加し\n"
"    \tしないで表示します\n"
"      -s\tARG を単一の項目としてヒストリ一覧に追加します\n"
"    \n"
"    FILENAME を与えた場合、FILENAME がヒストリファイルをして使用されます。そ"
"れが\n"
"    無く、$HISTFILE に値がある場合その値が使用されます。そうでなければ \n"
"    ~/.bash_history が使用されます。\n"
"\n"
"    もし $HISTTIMEFORMAT 変数が設定され、NULL で無ければ、strftime(3) の書"
"式\n"
"    文字列として各ヒストリ項目の時刻を表示する際に使用されます。それ以外は\n"
"    時刻は表示されません。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるかエラーが発生しない限り成功を返します。"

#: builtins.c:869
#, fuzzy
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"ジョブのステータスを表示します。\n"
"    \n"
"    アクティブなジョブを一覧表示します。JOBSPEC はジョブの出力を制限しま"
"す。\n"
"    オプションがない場合全てのアクティブなジョブのステータスが表示されま"
"す。\n"
"    \n"
"    オプション:\n"
"      -l\t通常の情報に加えてプロセスIDを一覧表示する\n"
"      -n\t最後の通知からステータスが変更になったプロセスのみ一覧表示\n"
"    \tする\n"
"      -p\tプロセスIDのみを一覧表示する\n"
"      -r\t実行中のジョブの出力を制限する\n"
"      -s\t停止中のジョブの出力を制限する\n"
"    \n"
"    -x が指定された場合、 COMMAND は ARGS に現れるジョブをプロセスグルー\n"
"    プリーダーのプロセス ID に置き換えた全てのジョブ指定の後に実行されま"
"す。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるかエラーが発生しない限り成功を返します。\n"
"    もし -x が使用された場合、COMMAND の終了ステータスを返します。"

#: builtins.c:896
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"現在のシェルからジョブを削除します。\n"
"    \n"
"    アクティブなジョブのテーブルから各引数の JOBSPEC を削除します。JOBSPEC が"
"指定\n"
"    されない場合、シェルが現在のジョブと考えているものが使用されます。\n"
"    \n"
"    オプション:\n"
"      -a\tJOBSPEC が与えられない時に全てのジョブを削除する\n"
"      -h\tシェルが SIGHUP を受け取った時に各 JOBSPEC のジョブに対して "
"SIGHUP \n"
"    \tが送られないようにマークする\n"
"      -r\t実行中のジョブのみ削除する\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションか JOBSPEC が与えられない限り成功を返します。"

#: builtins.c:915
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"ジョブにシグナルを送ります。\n"
"    \n"
"    PID または JOBSPEC で識別されるプロセスに SIGSPEC または SIGNUM で名付け"
"ら\n"
"    れるシグナルを送ります。もし SIGSPEC も SIGNUM も指定されない場合、"
"SIGTERM\n"
"    と見なされます。\n"
"    \n"
"    オプション:\n"
"      -s sig\tSIG をシグナル名とする\n"
"      -n sig\tSIG をシグナル番号とする\n"
"      -l\tシグナル名を一覧表示する。-l の後に引数が続いた場合、\n"
"    \tそれらは一覧表示されるべきシグナル番号であると見なされる\n"
"    \n"
"    Kill は次の2つの理由からシェル組み込み関数です。一つはプロセスIDの代わり"
"に\n"
"    ジョブIDを使用できるようにするためです。もう一つは作成したプロセスが制限"
"に\n"
"    達した時にプロセスを kill することができるようにするためです。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるかエラーが発生しない限り成功を返します。"

#: builtins.c:938
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"数式を評価します。\n"
"    \n"
"    各 ARG を数式として評価します。評価は固定長の整数として行われ、桁溢れは\n"
"    検査されません。しかし、0 による除算は捕捉されエラーとしてフラグが\n"
"    立ちます。次の演算子一覧は同一優先順位の演算子ごとにグループ化されてい\n"
"    ます。優先順位は降順になっています。\n"
"    \n"
"    \tid++, id--\t変数の後置インクリメント、デクリメント\n"
"    \t++id, --id\t変数の前置インクリメント、デクリメント\n"
"    \t-, +\t\t単項マイナス、プラス\n"
"    \t!, ~\t\t論理およびビット否定\n"
"    \t**\t\t指数演算\n"
"    \t*, /, %\t\t乗算、除算、剰余演算\n"
"    \t+, -\t\t加算、減算\n"
"    \t<<, >>\t\t左および右ビットシフト\n"
"    \t<=, >=, <, >\t比較\n"
"    \t==, !=\t\t等価、不等価\n"
"    \t&\t\tビット論理積\n"
"    \t^\t\tビット排他的論理和\n"
"    \t|\t\tビット論理和\n"
"    \t&&\t\t論理積\n"
"    \t||\t\t論理和\n"
"    \texpr ? expr : expr\n"
"    \t\t\t条件演算子\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\t代入\n"
"    \n"
"    シェル変数は被演算子として使用できます。変数名は数式内で (強制的に固定"
"長\n"
"    整数の) 値に置き換えられます。変数は数式内で使用する時には必ずしも\n"
"    整数属性を持っている必要はありません。\n"
"\n"
"    演算子は優先順位の順に評価されます。小括弧でくくられた数式は先に評価さ"
"れ、\n"
"    上記の優先順位を上書きするかもしれません。\n"
"    \n"
"    終了ステータス:\n"
"    ARG の最終的な評価値が 0 の場合 let は 1 を返します。それ以外の場合は\n"
"     let は 0 を返します。"

#: builtins.c:983
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\t\tuse Readline to obtain the line in an interactive shell\n"
"      -i text\tUse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than NCHARS\n"
"    \t\tcharacters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any delimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\t\tdo not allow backslashes to escape any characters\n"
"      -s\t\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of input "
"is\n"
"    \t\tnot read within TIMEOUT seconds.  The value of the TMOUT\n"
"    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns immediately,\n"
"    \t\twithout trying to read any data, returning success only if\n"
"    \t\tinput is available on the specified file descriptor.  The\n"
"    \t\texit status is greater than 128 if the timeout is exceeded\n"
"      -u fd\t\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"標準入力から一行読み込みフィールド毎に分割します。\n"
"    \n"
"    標準入力から一行読み込みます。または -u が指定されている場合はファイル記"
"述子\n"
"    FD から読み込みます。行は単語分割によってフィールドに分割され、最初の単語"
"が\n"
"    最初の NAME に、2番目の単語が2番目に NAME にという順で割り当てられます。"
"残っ\n"
"    た単語は全て最後の NAME に割り当てられます。変数 $IFS に設定された文字の"
"みが\n"
"    単語の区切りとして認識されます。\n"
"    \n"
"    もし NAME を指定しなかった場合、行は REPLY 変数に保存されます。\n"
"    \n"
"    オプション:\n"
"      -a array\t読み込んだ単語をインデックス型配列 ARRAY に順番に割り当てま"
"す。\n"
"    \t\t開始番号は 0 です。\n"
"      -d delim\t改行ではなく文字 DELIM が最初に現れるまで読み込みを続けます\n"
"      -e\t\t対話的シェルで行を得るのに Readline を使用します\n"
"      -i text\tReadline の初期テキストとして TEXT を使用します\n"
"      -n nchars\t改行が無くても文字数 NCHARS を読み込んだら復帰します。"
"NCHARS\n"
"    \t\tより前に区切り文字 (DELIMITER) が現れた場合は区切り文字が\n"
"    \t\t優先されます\n"
"      -N nchars\t厳密に文字数 NCHARS を読み込み復帰します。ただし、ファイル"
"終\n"
"    \t\t了(EOF) になるか読み込みタイムアウトが発生した場合は除きます。\n"
"    \t\t区切り文字 (DELIMITER) は無視されます\n"
"      -p prompt\t読み込み前に文字列 PROMPT を後ろに改行を付けないで表示しま"
"す\n"
"      -r\t\tバックスペースで文字をエスケープすることを禁止します\n"
"      -s\t\t端末から読み込まれる文字をエコーバックしません\n"
"      -t timeout\tTIMEOUT 秒以内に入力行が完全に読み込まれなかった場合\n"
"    \t\tタイムアウトを発生させ失敗として復帰します。TMOUT 変数の値が\n"
"    \t\tデフォルトのタイムアウトです。TIMEOUT を小数にすることもでき\n"
"    \t\tます。もし TIMEOUT が 0 の場合、指定したファイル記述子からの\n"
"    \t\t入力が使用可能な場合にのみ読み込み、成功返します。タイムアウ\n"
"    \t\tト発生時の終了ステータスは128より大きくなります\n"
"      -u fd\t\t読み込みに標準入力ではなくファイル記述子 FD を使用します\n"
"    \n"
"    終了ステータス:\n"
"    ファイル終了(EOF)、読み込みタイムアウト、-u に無効なファイル記述子が与"
"え\n"
"    られた場合を除き0を返します。"

#: builtins.c:1028
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"シェル関数から復帰します。\n"
"    \n"
"    N で指定した値を戻り値として関数または source されたスクリプトを終了しま"
"す。\n"
"    N が指定されない場合、関数またはスクリプトで最後に実行したコマンドの戻り"
"値\n"
"    が使用されます。\n"
"    \n"
"    終了ステータス:\n"
"    戻り値 N、またはシェルが関数またはスクリプトを実行していない場合は失敗"
"を\n"
"    返します。"

#: builtins.c:1041
#, fuzzy
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG trap is inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"シェルオプションや位置パラメーターの値を設定・消去します\n"
"    \n"
"    シェル属性や位置パラメーターの値を変更、またはシェル変数の名前と値\n"
"    を表示します。\n"
"    \n"
"    オプション:\n"
"      -a  変数を変更または変更してエクスポートするようにマークする\n"
"      -b  ジョブ終了を即時通知する\n"
"      -e  コマンドの終了ステータスが 0 以外の場合は即時終了する\n"
"      -f  ファイル名生成 (globbing) を無効にする\n"
"      -h  検索したコマンドの位置を記憶する\n"
"      -k  全ての値を設定する引数がコマンド実行時の環境に配置される。コ\n"
"          マンド名の前にあるものに限らない\n"
"      -m  ジョブ制御を有効にする\n"
"      -n  コマンドを読み込むが実行しない\n"
"      -o option-name\n"
"          option-name に対応した変数を設定する:\n"
"              allexport    -a と同様\n"
"              braceexpand  -B と同様\n"
"              emacs        emacs スタイルの行編集インターフェースを使用\n"
"              errexit      -e と同様\n"
"              errtrace     -E と同様\n"
"              functrace    -T と同様\n"
"              hashall      -h と同様\n"
"              histexpand   -H と同様\n"
"              history      コマンドヒストリを有効にする\n"
"              ignoreeof    ファイル終了 (EOF) 読み込み時にシェルを終了\n"
"                           しない\n"
"              interactive-comments\n"
"                           対話コマンドでコメントの使用を許可する\n"
"              keyword      -k と同様\n"
"              monitor      -m と同様\n"
"              noclobber    -C と同様\n"
"              noexec       -n と同様\n"
"              noglob       -f と同様\n"
"              nolog        受け付けられるが無視される\n"
"              notify       -b と同様\n"
"              nounset      -u と同様\n"
"              onecmd       -t と同様\n"
"              physical     -P と同様\n"
"              pipefail     パイプラインの戻り値を最後に 0 以外で終了したコ"
"マ\n"
"                           ンドの終了ステータスにする。0 以外のステータスで\n"
"                           終了したコマンドが無い場合には 0 にする。\n"
"              posix        Posix 標準とデフォルト動作が異なる bash の動作を\n"
"                           Posix と一致するようにする\n"
"              privileged   -p と同様\n"
"              verbose      -v と同様\n"
"              vi           vi スタイルの行編集インターフェースを使用する\n"
"              xtrace       -x と同様\n"
"      -p  実 uid と実効 uid が異なる時に常にオンになる。$ENV ファイルの処理\n"
"          およびシェル関数のインポートが無効になる。このオプションをオフに\n"
"          すると実効 uid, gid が実 uid, gid と同じに設定される\n"
"      -t  一つのコマンドを読み込み、実行した後に終了する\n"
"      -u  代入時に変数を未設定にするとエラーとして扱う\n"
"      -v  シェルの入力行を読み込んだ通りに表示する\n"
"      -x  実行されるコマンドと引数をその通りに表示する\n"
"      -B  中括弧の展開をシェルで行う\n"
"      -C  設定した場合、リダイレクトで既存の通常ファイルを上書きすることを\n"
"          禁止する\n"
"      -E  設定した場合 ERR トラップがシェル関数に継承される\n"
"      -H  ! スタイルのヒストリ置換を有効にする。このフラグは対話的シェルで\n"
"          はデフォルトでオンになる\n"
"      -P  設定した場合、 cd などのカレントディレクトリを変更するコマンドを\n"
"          実行した時にシンボリックリンクを辿らない\n"
"      -T  設定した場合、 DEBUG トラップがシェル関数に継承される\n"
"      --  これ以降の引数を位置パラメーターとして割り当てる。もしこれ以降の\n"
"          引数が無い場合は位置パラメーターは設定解除される\n"
"      -   これ以降の引数を位置パラメーターとして割り当てる。-x と -v \n"
"          オプションはオフになる\n"
"    \n"
"    - の代わりに + を使用すると、フラグがオフになります。フラグはシェルの起\n"
"    動時にも使用することもできます。現在の設定されているフラグの組は $- で\n"
"    得られます。残りの n 個の引数 ARG は位置パラメータとして$1, $2, .. $n\n"
"    の順に設定されます。もし引数 ARG が与えられない場合、全てのシェル変数が\n"
"    表示されます。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられない限り成功を返します。"

#: builtins.c:1126
#, fuzzy
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"シェル変数および関数の値・属性を消去します。\n"
"    \n"
"    各 NAMEに対して関連する値または関数を削除します。\n"
"    \n"
"    オプション:\n"
"      -f\t各 NAME をシェル関数として扱います\n"
"      -v\t各 NAME をシェル変数として扱います\n"
"    \n"
"    オプションが無い場合、最初に変数を消去しようと試みます。失敗した場合に"
"は\n"
"    関数を消去しようと試みます。\n"
"    \n"
"    いくつかの変数は消去できません。`readonly' も参照してください。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるか NAME が読み取り専用の場合を除き成功を返し"
"ます。"

#: builtins.c:1148
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"シェル変数に export 属性を設定します。\n"
"    \n"
"    各 NAME に対して後に続けて実行されるコマンドの環境変数として自動的に\n"
"    エクスポートされるようにマークします。VALUE が与えられた場合はエクス\n"
"    ポートする前に値を設定します。\n"
"\n"
"    オプション:\n"
"      -f\tシェル関数を参照します\n"
"      -n\t各 NAME に対してエクスポート属性を削除します\n"
"      -p\t全てのエクスポートされた変数・関数一覧を表示します\n"
"    \n"
"    引数 `--' 以降はオプションとして処理されません。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるか、無効な NAME が与えられない限り成功\n"
"    を返します。"

#: builtins.c:1167
#, fuzzy
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions, depending "
"on\n"
"            whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"シェル変数を変更不可にします。\n"
"    \n"
"    各 NAME を読み取り専用にします。これらの NAME の値はこれ以降の代入で\n"
"    変更ができなくなります。VALUE が与えられた場合、読み取り専用にする前\n"
"    に値が設定されます。\n"
"    \n"
"    オプション:\n"
"      -a\tインデックス型配列変数を示します\n"
"      -A\t連想配列変数を示します\n"
"      -f\tシェル関数を示します\n"
"      -p\t全ての読み取り専用変数・関数の一覧を表示します\n"
"    \n"
"    引数 `--' は以降のオプション処理を無効にします\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるか、与えられた NAME が無効な場合を除き成功\n"
"    を返します。"

#: builtins.c:1189
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"位置パラメーターをシフトします。\n"
"    \n"
"    位置パラメーター名 $N+1,$N+2 ... を $1,$2 ... に変更します。 \n"
"    N が与えられなかった場合、1 と見なされます。\n"
"    \n"
"    終了ステータス:\n"
"    Nが負の値または $# より大きい場合を除き成功を返します。"

#: builtins.c:1201 builtins.c:1216
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"ファイルを読み込み現在のシェルでコマンドを実行します。\n"
"    \n"
"    FILENAME を読み込み現在のシェルでコマンドを実行します。$PATH の項目が\n"
"    FILENAME が含まれるディレクトリを見つけるために使用されます。引数\n"
"    ARGUMENTS が与えられた場合 FILENAME を実行する際の位置パラメーターと\n"
"    して使用されます。\n"
"    \n"
"    終了ステータス:\n"
"    FILENAME で最後に実行したコマンドのステータスを返します。FILENAME が\n"
"    読み込めなかった場合は失敗を返します。"

#: builtins.c:1232
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"シェルの実行を一時停止します。\n"
"    \n"
"    SIGCONT シグナルを受け取るまでこのシェルの実行を一時停止します。強制\n"
"    オプションが無い限りログインシェルは一時停止できません。\n"
"    \n"
"    オプション:\n"
"      -f\tシェルがログインシェルだとしても強制的に一時停止する\n"
"    \n"
"    終了ステータス:\n"
"    ジョブ制御が有効でないかエラーが発生しない限り成功を返します。"

#: builtins.c:1248
#, fuzzy
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR\t True if the shell variable VAR is set\n"
"      -R VAR\t True if the shell variable VAR is set and is a name "
"reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"条件式を評価します。\n"
"    \n"
"    式 EXPR の結果に応じて 0 (真、true) または 1 (偽、false) を返します。\n"
"    式は単項演算子または二項演算子です。単項演算子はファイルのステータス\n"
"    を評価するために使用されます。文字列演算子と数値比較演算子も加えて\n"
"    存在します。\n"
"    \n"
"    ファイル演算子:\n"
"    \n"
"      -a FILE        ファイルが存在する時に真(true)\n"
"      -b FILE        ファイルがブロック特殊デバイスの時に真(true)\n"
"      -c FILE        ファイルがキャラクタ特殊デバイスの時に真(true)\n"
"      -d FILE        ファイルがディレクトリの時に真(true)\n"
"      -e FILE        ファイルが存在する時に真(true)\n"
"      -f FILE        ファイルが存在し、通常ファイルの時に真(true)\n"
"      -g FILE        ファイルに setgid が設定されている時に真(true)\n"
"      -h FILE        ファイルがシンボリックリンクの時に真(true)\n"
"      -L FILE        ファイルがシンボリックリンクの時に真(true)\n"
"      -k FILE        ファイルに sticky ビットが設定されている時に真(true)\n"
"      -p FILE        ファイルが名前付きパイプの時に真(true)\n"
"      -r FILE        ファイルがユーザに対して読み込み可能な時に真(true)\n"
"      -s FILE        ファイルが存在し、かつ空ファイルでない場合に真(true)\n"
"      -S FILE        ファイルがソケットの場合に真(true)\n"
"      -t FD          FD(ファイル識別子) が端末に開いている時に真(true)\n"
"      -u FILE        ファイルに setuid が設定されている時に真(true)\n"
"      -w FILE        ファイルがユーザに対して書き込み可能な時に真(true)\n"
"      -x FILE        ファイルがユーザに対して実行可能な時に真(true)\n"
"      -O FILE        ファイルをユーザが実効的に所有されている時に真(true)\n"
"      -G FILE        ファイルのグループにユーザが実効的に所属している時に真"
"(true)\n"
"      -N FILE        ファイルを最後に読み込んだ以降に変更されている時に真"
"(true)\n"
"    \n"
"      FILE1 -nt FILE2  file1 が file2 より新しい時(更新時間に基づく)に真"
"(true)\n"
"                       \n"
"    \n"
"      FILE1 -ot FILE2  file1 が file2 より古い時に真(true)\n"
"    \n"
"      FILE1 -ef FILE2  file1 が file2 に対するハードリンクの時に真(true)\n"
"    \n"
"    文字列演算子:\n"
"    \n"
"      -z STRING      文字列が空の時に真(true)\n"
"    \n"
"      -n STRING\n"
"         STRING      文字列が空でない時に真(true)\n"
"    \n"
"      STRING1 = STRING2\n"
"                     文字列が同一の時に真(true)\n"
"      STRING1 != STRING2\n"
"                     文字列が同一でない時に真(true)\n"
"      STRING1 < STRING2\n"
"                     辞書順で STRING1 が STRING2 より前の時に真(true)\n"
"      STRING1 > STRING2\n"
"                     辞書順で STRING1 が STRING2 より後の時に真(true)\n"
"    \n"
"    その他演算子:\n"
"    \n"
"      -o OPTION      シェルオプション OPTION が有効な時に真(true)\n"
"      -v VAR         シェル変数 VAR が設定されている時に真(true)\n"
"      ! EXPR         式 expr が偽(fales)の時に真(true)\n"
"      EXPR1 -a EXPR2 式 expr1 および expr2 の両方とも真(true)の時に真(true)\n"
"      EXPR1 -o EXPR2 式 expr1 または expr2 のいずれかが真(true)の時に真"
"(true)\n"
"    \n"
"      arg1 OP arg2   数値比較演算を行なう。OP は -eq, -ne, -lt, -le, -gt,\n"
"                     または -ge のいずれかとなる。\n"
"    \n"
"    数値演算二項演算子は ARG1 と ARG2 の関係がそれぞれ、等しい(-eq)、\n"
"    等しくない(-ne)、より小さい(-lt)、以下(-le)、より大きい(-gt)、または\n"
"    以上(-ge)の時に真(true)を返します。\n"
"    \n"
"    終了ステータス:\n"
"    式 EXPR の評価値が真(true)の時に成功を返します。EXPR の評価値が偽(false) "
"または\n"
"    引数が無効な場合に失敗を返します。"

#: builtins.c:1329
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"条件式を評価します。\n"
"    \n"
"    これは test 組み込み関数と同義語です。ただし、最後の引数に開始の`['と一"
"致\n"
"    するように文字`]'を与えなければいけません。"

#: builtins.c:1338
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"プロセスの時間を表示します。\n"
"    \n"
"    シェルとその子プロセスが使用したユーザー時間とシステム時間それぞれの累積"
"を\n"
"    表示します。\n"
"    \n"
"    終了ステータス:\n"
"    常に成功を返します。"

#: builtins.c:1350
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"シグナルまたは他のイベントをトラップします。\n"
"    \n"
"    シェルがシグナルを受け取るか他の条件が発生した時に実行されるハンドラー"
"を\n"
"    定義および有効化します。\n"
"    \n"
"    ARG はシグナル SIGNAL_SPEC を受け取った時に読み込まれ実行されるコマンド\n"
"    です。もし ARG が無い (かつシグナル SIGNAL_SPEC が与えられた場合) また"
"は\n"
"    `-' の場合、各指定したシグナルはオリジナルの値にリセットされます。\n"
"    ARG が NULL 文字列の場合、各シグナル SIGNAL_SPEC はシェルにおよび起動さ\n"
"    れたコマンドによって無視されます。\n"
"    \n"
"    もし SIGNAL_SPEC が EXIT (0) の場合、ARG がシェルの終了時に実行されま"
"す。\n"
"    もし SIGNAL_SPEC が DEBUG の場合 ARG は単に毎回コマンドの前に実行されま"
"す。\n"
"    もし SIGNAL_SPEC が RETURN の場合 ARG はシェル関数または . か source に\n"
"    よって実行されたスクリプトが終了した時に実行されます。 SIGNAL_SPEC が "
"ERR\n"
"    の場合、-e オプションが有効な場合にシェルが終了するようなコマンド失敗が"
"発\n"
"    生するたびに実行されます。\n"
"    \n"
"    もし引数が与えられない場合、 trap は各シグナルに割り当てられたコマンド"
"の\n"
"    一覧を表示します。\n"
"    \n"
"    オプション:\n"
"      -l\tシグナル名とシグナル番号の対応一覧を表示します\n"
"      -p\t各 SIGNAL_SPEC に関連づけられた trap コマンドを表示します\n"
"    \n"
"    各 SIGNAL_SPEC は <signal.h> にあるシグナル名かシグナル番号です。シグ\n"
"    ナル名は大文字小文字を区別しません。また SIG 接頭辞はオプションです。\n"
"    シグナルはシェルに対して \"kill -signal $$\" で送ることができます。\n"
"    \n"
"    終了ステータス:\n"
"    SIGSPEC が無効か、無効なオプションを与えられない限り成功を返します。"

#: builtins.c:1386
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"コマンドの種類に関する情報を表示します。\n"
"    \n"
"    各 NAME に対してコマンド名として使われた時にどのように解釈されるかを\n"
"    示します。\n"
"    \n"
"    オプション:\n"
"      -a\tNAME という名前になっている実行可能なものの全ての位置を表示し\n"
"    \tます。これには `-p' が同時に指定されていない場合に限ってエイリアス、\n"
"    \t組み込み関数、シェル関数も含みます\n"
"      -f\tシェル関数の検索を抑止します\n"
"      -P\t各 NAME に対して PATH 探索を強制します。エイリアス、組み込み\n"
"    \t関数、シェル関数があったとしても実行されるディスク上のファイル名を\n"
"    \t返します\n"
"      -p\t実行されるディスク上のファイル名を返します。`type -t NAME'\n"
"    \tが `file' を返さない場合、何も返しません。\n"
"      -t\t次のいずれかの単語を返します。`alias', `keyword', `function',\n"
"    \t `builtin', `file' or `'。それぞれ NAME がエイリアス、シェル予約語、\n"
"    \tシェル関数、シェル組み込み関数、ディスク上のファイル、何も見つからな"
"い\n"
"    \tに対応します。\n"
"    \n"
"    引数:\n"
"      NAME\t解釈するコマンドの名前です。\n"
"    \n"
"    終了ステータス:\n"
"    全ての NAME が見つかった場合に成功を返します。どれかが見つからなかった場"
"合\n"
"    は失敗を返します。"

#: builtins.c:1417
#, fuzzy
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -T    the maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"シェルの資源制限を変更します。\n"
"    \n"
"    シェルおよびシェルが作成するプロセスが使用可能な資源に対する制御を提供し"
"ます。\n"
"    ただし、システムがそのような制御を許可している場合です。\n"
"    \n"
"    オプション:\n"
"      -S\t`soft' 資源制限を使用します\n"
"      -H\t`hard' 資源制限を使用します\n"
"      -a\t現在の全ての資源制限を表示します\n"
"      -b\tソケットバッファサイズ\n"
"      -c\t作成されるコアファイルの最大サイズ\n"
"      -d\tプロセスデータセグメントの最大サイズ\n"
"      -e\tスケジュール優先度の最大値 (`nice')\n"
"      -f\tシェル及び子プロセスが書き込み可能なファイルサイズの最大値\n"
"      -i\t保留するシグナルの最大数\n"
"      -l\tメモリにロックできるプロセスの最大サイズ\n"
"      -m\t最大のメモリサイズ\n"
"      -n\tファイル記述子を開くことができる最大数\n"
"      -p\tパイプのバッファサイズ\n"
"      -q\tPOSIX message queues の最大バイト数\n"
"      -r\tリアルタイムスケジュール優先度の最大値\n"
"      -s\tスタックサイズの最大値\n"
"      -t\tCPU時間総量の最大値 (秒単位)\n"
"      -u\tユーザープロセスの最大数\n"
"      -v\t仮想メモリのサイズ\n"
"      -x\tファイルロックの最大数\n"
"    \n"
"    LIMIT が与えられた場合、指定した資源に対する新しい値になります。特別な\n"
"    LIMIT の値である `soft'、`hard'、および `unlimited' は現在の `soft' 制"
"限\n"
"    現在の`hard' 制限および制限なしをそれぞれ意味します。\n"
"    それ以外の場合、指定した資源の現在の値が表示されます。オプションが与え\n"
"    られなかった場合 -f と見なされます。\n"
"    \n"
"    値は 1024 バイト単位で増加します。例外は -t が秒単位、-p が 512バイト\n"
"    単位、および -u は1プロセス単位です。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるかエラーが発生しない限り成功を返します。"

#: builtins.c:1465
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"ファイルのモードマスクを表示または設定します。\n"
"    \n"
"    ユーザーがファイル作成時のマスクを MODE に設定します。MODE が指定されない"
"場合\n"
"    現在のマスクの値を表示します。\n"
"    \n"
"    MODE が数値で開始した場合8進数として解釈されます。それ以外は chmod(1) で"
"受け\n"
"    入れられるシンボルモードの文字列として扱われます。\n"
"    \n"
"    オプション:\n"
"      -p\tMODE が指定されない場合、入力として再利用可能な形式で表示します\n"
"      -S\tシンボルモードで出力します。それ以外は8進数で出力します\n"
"    \n"
"    終了ステータス:\n"
"    MODE が無効か、無効なオプションが与えられない限り成功を返します。"

#: builtins.c:1485
#, fuzzy
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a a job specification, waits for all "
"processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for the next job to terminate and\n"
"    returns its exit status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given."
msgstr ""
"ジョブの実行完了を待ち、終了ステータスを返します。\n"
"    \n"
"    ID で識別されるプロセス (プロセスID または ジョブ指定) を待ち、その終了\n"
"    ステータスを返します。ID が与えられない場合、現在アクティブな全ての子プ\n"
"    ロセスを待ち 0 を返します。ID がジョブ指定の場合ジョブのパイプラインに\n"
"    ある全てのプロセスを待ちます。\n"
"    \n"
"    終了ステータス:\n"
"    ID の終了ステータスを返します。IDが無効であるか、無効なオプションが\n"
"    与えられた場合には失敗を返します。"

#: builtins.c:1506
#, fuzzy
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""
"プロセスの実行完了を待ち、終了ステータスを返します。\n"
"    \n"
"    指定されたプロセスを待ち、その終了ステータスを返します。PID が与えられ\n"
"    ない場合、現在アクティブな全ての子プロセスを待ち、0 を返します。PID は\n"
"    プロセスIDでなければなりません。\n"
"    \n"
"    終了ステータス:\n"
"    IDの終了ステータスを返します。IDが無効か、無効なオプションが与えられた\n"
"    場合はエラーを返します。"

#: builtins.c:1521
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"リストの各要素に対してコマンドを実行します。\n"
"    \n"
"    `for' ループではリストの各要素に対して一連のコマンドを実行します。\n"
"    `in WORDS ...;' が存在しない場合、`in \"$@\"' であると見なされます。\n"
"    WORDS の要素が NAME の値として代入され COMMANDS が実行されます。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドのステータスを返します。"

#: builtins.c:1535
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"算術 for ループ\n"
"    \n"
"    以下と等価です。\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1、EXP2、および EXP3 は数式です。いずれかの数式を省略した場合、\n"
"    値が 1 であるとして評価されます。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドのステータスを返します。"

#: builtins.c:1553
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"一覧から項目を選択し、COMMANDS を実行します。\n"
"    \n"
"    WORDS が展開され、項目の一覧が生成されます。展開された項目\n"
"    の組は標準エラー出力に表示されます。各項目の前には数値が付け\n"
"    られます。`in WORDS' が存在しない場合、`in \"$@\"' と仮定されます。\n"
"    次に PS3 プロンプトが表示され、標準入力から 1 行読み込まれます。\n"
"    行が表示した項目の一つに関連づけられた数値で構成されていた場合、\n"
"    NAME に項目が設定されます。空行の場合、プロンプトが再度表示され\n"
"    ます。ファイル終了(EOF) が読み込まれた場合、コマンドが終了します。\n"
"    それ以外の場合は NAME に null が設定されます。読み込んだ行は変数\n"
"    REPLY に保存されます。行が読み込まれるごとに break コマンドが実\n"
"    行されるまで COMMANDS が繰り返し実行されます。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドのステータスを返します。"

#: builtins.c:1574
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"パイプラインを実行する時に消費された時間を報告します。\n"
"    \n"
"    PIPELINE を実行し、終了時に PIPELINE を実行するために費やされた実\n"
"    時間、ユーザー CPU 時間、およびシステム CPU 時間の要約を表示します。\n"
"    \n"
"    オプション:\n"
"      -p\t移植性のある Posix 形式で時間の要約を表示します\n"
"    \n"
"    変数 TIMEFORMAT の値が出力の形式として使用されます。\n"
"    \n"
"    終了ステータス:\n"
"    PIPELINE の戻り値が終了ステータスとなります。"

#: builtins.c:1591
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"パターン一致の結果に基づいてコマンドを実行します。\n"
"    \n"
"    WORD が PATTERN に一致するかどうかに基づいて選択的に COMMANDS を実行しま"
"す。\n"
"    複数のパターンを区切るために `|' が使用されます。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドのステータスを返します。"

#: builtins.c:1603
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"条件に従ってコマンドを実行します。\n"
"    \n"
"    `if COMMANDS' を実行します。この終了ステータスが 0 の場合、`then "
"COMMANDS'\n"
"    を実行します。そうでない場合は、各 `elif COMMANDS' を順番に実行し、その\n"
"    終了ステータスが 0 の場合に、関連した `then COMMANDS' を実行し、if 文が\n"
"    完了します。それ以外の場合、 `else COMMANDS' が存在する場合には実行され\n"
"    ます。文全体の終了ステータスは、最後に実行したコマンドの終了ステータス"
"か、\n"
"    または、テストした条件に true となるものが無い場合は 0 です。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドの終了ステータスを返します。"

#: builtins.c:1620
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"テストが成功する限りコマンドを実行します。\n"
"    \n"
"    `while' COMMANDS にある最後のコマンドの終了ステータスが 0 である間 \n"
"     COMMANDS を展開して実行します。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドのステータスを返します。"

#: builtins.c:1632
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"テストが失敗する限りコマンドを実行します。\n"
"    \n"
"    `until' COMMANDS にある最後のコマンドの終了ステータスが 0 でない間\n"
"     COMMANDS を展開して実行します。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドのステータスを返します。"

#: builtins.c:1644
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""
"NAME という名前の非同期プロセスを作成します。\n"
"    \n"
"    COMMAND を非同期で実行します。コマンドの標準出力および標準入力は実行\n"
"    しているシェルのインデックス型配列変数 NAME の要素添字 0、1 に設定\n"
"    されるファイル記述子へのパイプとして接続されます。\n"
"    デフォルトの NAME は \"COPROC\" です。\n"
"    \n"
"    終了ステータス:\n"
"    COMMAND の終了ステータスを返します。"

#: builtins.c:1658
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"シェル関数を定義します。\n"
"    \n"
"    NAME という名前のシェル関数を作成します。単にコマンドとして起動された時"
"は\n"
"    NAME は COMMANDs をシェルのコンテキスト内で呼び出します。NAME を起動し"
"た\n"
"    時に引数は関数に $1...$n という位置パラメーターで、関数名は $FUNCNAME\n"
"    変数として渡されます。\n"
"    \n"
"    終了ステータス:\n"
"    NAME が読み取り専用でない限り成功を返します。"

#: builtins.c:1672
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"複数のコマンドを一つにグループ化します。\n"
"    \n"
"    複数のコマンドをグループにして1セットとして実行します。これはコマンド\n"
"    のセット全体をリダイレクトする一つの方法です。\n"
"    \n"
"    終了ステータス:\n"
"    最後に実行したコマンドのステータスを返します。"

#: builtins.c:1684
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"ジョブをフォアグラウンドで再開します。\n"
"    \n"
"    `fg' コマンドの引数として与える JOB_SPEC と等価です。停止または\n"
"    バックグラウンドのジョブを再開します。JOB_SPEC はジョブ名または\n"
"    ジョブ番号で指定します。JOB_SPEC の後に `&' を続けると、`bg' の\n"
"    引数として与えられたようにジョブをバックグラウンドにします。\n"
"    \n"
"    終了ステータス:\n"
"    再開されたジョブの終了ステータスを返します。"

#: builtins.c:1699
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"算術式を評価します。\n"
"    \n"
"    算術式の規定に基づいて EXPRESSION を評価します。\"let EXPRESSION\"\n"
"    と等価です。\n"
"    \n"
"    終了ステータス:\n"
"    EXPRESSION の評価値が 0 の場合は 1、それ以外は 0 を返します。"

#: builtins.c:1711
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"条件式のコマンドを実行します。\n"
"    \n"
"    条件式 EXPRESSION の評価結果に基づいて 0 または 1 を返します。\n"
"    条件式は test 組み込み関数と同じ優先順位で組み合わされます。また、\n"
"    次の演算子とも組み合わされます。\n"
"    \n"
"      ( EXPRESSION )\tEXPRESSION の値を返します\n"
"      ! EXPRESSION\t\tEXPRESSION が true の時 false を返します。それ\n"
"                  \t\t以外は false を返します\n"
"      EXPR1 && EXPR2\tEXPR1 および EXPR2 の両方が true の時 true を返しま"
"す。\n"
"      \tそれ以外は false を返します。\n"
"      EXPR1 || EXPR2\tEXPR1 および EXPR2 のいずれかが true の時 true を返し\n"
"      \tます。それ以外は false を返します。\n"
"    \n"
"    `==' および `!=' 演算子が使用された場合、演算子の右側の文字列をパターン"
"と\n"
"    した左側の文字列に対するパターン一致処理が行われます。\n"
"    `=~' 演算子が使用された場合、演算子の右側の文字列が正規表現として扱われ"
"ま\n"
"    す。\n"
"    \n"
"    && および || 演算子は EXPR1 で式の値を決定するのに十分な場合は EXPR2 を\n"
"    評価しません。\n"
"    \n"
"    終了ステータス:\n"
"    EXPRESSION の値に基づいて 0 または 1 を返します。"

#: builtins.c:1737
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"通常の変数名とその使用法。\n"
"    \n"
"    BASH_VERSION\tBashのバージョン情報。\n"
"    CDPATH\t`cd`の引数として与えられたディレクトリを検索する際に\n"
"    \t\t使用されるコロン (:) で区切られたディレクトリの一覧。\n"
"    GLOBIGNORE\tパス名を展開する時に無視されるコロン (:) で区切られた\n"
"    \t\tファイル名パターンの一覧。\n"
"    HISTFILE\tコマンドヒストリが保存されるファイル名。\n"
"    HISTFILESIZE\tヒストリファイルに保存することができる最大行数。\n"
"    HISTSIZE\t実行中のシェルがアクセスできる最大ヒストリ行数。\n"
"    HOME\tログインディレクトリの完全パス名。\n"
"    HOSTNAME\t現在のホスト名。\n"
"    HOSTTYPE\tこのバージョンの Bash を実行している CPU の種類。\n"
"    IGNOREEOF\tシェルがファイル終了 (EOF) 文字を単一の入力として受け\n"
"    \t\t取った時の動作を制御します。設定されている場合、空白行\n"
"    \t\tで EOF 文字をその数連続して受け取った時にシェルを終了\n"
"    \t\tします (デフォルト 10)。設定が解除された場合、EOF で\n"
"    \t\t入力が終了することを意味します。\n"
"    MACHTYPE\tBash が実行されている現在のシステムを表す文字列。\n"
"    MAILCHECK\tBash がメールを確認する頻度 (秒単位)。\n"
"    MAILPATH\tBash が新規メールを確認するコロン (:) で区切られた\n"
"    \t\tファイル名の一覧。\n"
"    OSTYPE\tこのバージョンの Bash を実行している OS のバージョン。\n"
"    PATH\tコマンドを検索する際に使用されるコロン (:) で区切ら\n"
"    \t\tれたディレクトリの一覧。\n"
"    PROMPT_COMMAND\tプライマリプロンプトが表示される前に毎回実行\n"
"    \t\tされるコマンド。\n"
"    PS1\t\tプライマリプロンプト文字列。\n"
"    PS2\t\tセカンダリプロンプト文字列。\n"
"    PWD\t\t現在のディレクトリの完全パス名。\n"
"    SHELLOPTS\tコロン (:) で区切られた有効なシェルオプション一覧。\n"
"    TERM\t現在の端末種類名。\n"
"    TIMEFORMAT\t`time' 予約語による時間統計情報の表示書式。\n"
"    auto_resume\tnull で無い場合、その行に現れたコマンドは、まず現在停止\n"
"    \t\tされているジョブから検索されます。それで見つかった場合、\n"
"    \t\tジョブがフォアグランドになります。値が `exact' の場合、\n"
"    \t\tコマンドが停止しているジョブの一覧と厳密に一致していなけ\n"
"    \t\tればなりません。値が `substring' の場合、コマンドがジョ\n"
"    \t\tブの部分文字列に一致しなければなりません。その他の値の\n"
"    \t\t場合はコマンドが停止しているジョブの先頭部分に一致しな\n"
"    \t\tければなりません。\n"
"    histchars\tヒストリ展開とクイック置換を制御する文字。最初の文字が\n"
"    \t\tヒストリ展開の文字で通常は `!' です。二番目がクイック\n"
"    \t\t置換で通常は `^' です。三番目がヒストリのコメントで\n"
"    \t\t通常は `#' です。\n"
"    HISTIGNORE\tヒストリ一覧に保存されるコマンドを決める時に使用される\n"
"    \t\tコロン (:) で区切られたパターンの一覧。\n"

#: builtins.c:1794
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"ディレクトリをディレクトリスタックに加えます。\n"
"    \n"
"    ディレクトリをディレクトリスタックの先頭に加える、またはディレ\n"
"    クトリを回転してカレントディレクトリがスタックの先頭になるよう\n"
"    にします。引数がない場合、先頭の二つのディレクトリを入れ替えま\n"
"    す。\n"
"    \n"
"    オプション:\n"
"      -n\tスタックに加えた時、通常のディレクトリ変更を抑止し\n"
"    \tます。よってスタックのみ操作されます。\n"
"    \n"
"    引数:\n"
"      +N\tN 番目のディレクトリが先頭になるようスタックを回転\n"
"    \tします (`dirs' で表示される一覧の左から数えます。開始番号\n"
"    \tは 0 です)。\n"
"    \n"
"      -N\tN 番目のディレクトリが先頭になるようスタックを回転\n"
"    \tします (`dirs' で表示される一覧の右から数えます。開始番号\n"
"    \tは 0 です)。\n"
"    \n"
"      dir\tDIR をディレクトリスタックの先頭に加え、カレント\n"
"    \tディレクトリにします。\n"
"    \n"
"    `dirs' 組み込み関数でディレクトリスタックを表示します。\n"
"    \n"
"    終了ステータス:\n"
"    無効な引数が与えられるかディレクトリ変更が失敗しない限り成功を\n"
"    返します。"

#: builtins.c:1828
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"ディレクトリスタックからディレクトリを削除します。\n"
"    \n"
"    ディレクトリスタックから要素を削除します。引数がない場合、ディレクトリ\n"
"    スタックの先頭から削除し、新しいスタック先頭のディレクトリに移動しま"
"す。\n"
"    \n"
"    オプション:\n"
"      -n\tスタックからディレクトリを削除した時、通常のディレクトリ変\n"
"    \t更を抑止します。よってスタックのみ操作されます。\n"
"    \n"
"    引数:\n"
"      +N\t`dirs' で表示される一覧の左から数えて N 番目の要素を削除し\n"
"    \tます。開始番号は 0 です。例えば、`popd +0' は先頭のディレクトリを\n"
"    \t削除します。`popd +1' は二番目です。\n"
"    \n"
"      -N\t`dirs' で表示される一覧の右から数えて N 番目の要素を削除し\n"
"    \tます。開始番号は 0 です。例えば、`popd -0' は最後のディレクトリを\n"
"    \t削除します。`popd -1' は最後から二番目です。\n"
"    \n"
"    `dirs' 組み込み関数でディレクトリスタックを表示します。\n"
"    \n"
"    終了ステータス:\n"
"    無効な引数が与えられるかディレクトリ変更が失敗しない限り成功を\n"
"    返します。"

#: builtins.c:1858
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"ディレクトリスタックを表示します。\n"
"    \n"
"    現在記憶されているディレクトリ一覧を表示します。ディレクトリは `pushd'\n"
"    コマンドを使用して一覧に追加され、`popd' コマンドを通して一覧から取り\n"
"    戻されます。\n"
"    \n"
"    オプション:\n"
"      -c\t全ての要素を削除してディレクトリスタックを空にします\n"
"      -l\tホームディレクトリからの相対パスを ~ を先頭にした形式で\n"
"    \t表示しません\n"
"      -p\t一行に一つのディレクトリスタック要素を表示します\n"
"      -v\t一行に一つのディレクトリスタック要素を位置に関する番号\n"
"    \tをつけて表示します\n"
"    \n"
"    引数:\n"
"      +N\tdirs を引数無しで実行した時の一覧で左から数えて N 番目の\n"
"    \t要素のみを表示します。開始番号は 0 です。\n"
"    \n"
"      -N\tdirs を引数無しで実行した時の一覧で右から数えて N 番目の\n"
"    \t要素のみを表示します。開始番号は 0 です。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるかエラーが発生しない限り成功を返します。"

#: builtins.c:1887
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not "
"each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"シェルオプションを設定、および設定解除します。\n"
"    \n"
"    各シェルオプション OPTNAME の設定を変更します。引数がない場合、シェル\n"
"    オプション全てを、それぞれ設定されているか否かを含めて表示します。\n"
"    \n"
"    オプション:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tそれぞれのシェルオプションを、状態を含めて表示します\n"
"      -q\t出力を抑止します\n"
"      -s\tOPTNAME をそれぞれ有効 (設定) にします\n"
"      -u\tOPTNAME をそれぞれ無効 (非設定) にします\n"
"    \n"
"    終了ステータス:\n"
"    OPTNAME が有効な場合は成功を返します。無効なオプションが与えられた場合\n"
"    または OPTNAME が無効な場合は失敗を返します。"

#: builtins.c:1908
#, fuzzy
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %(fmt)T output the date-time string resulting from using FMT as a "
"format\n"
"            string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"ARGUMENTS を FORMAT で書式整形して表示します。\n"
"    \n"
"    オプション:\n"
"      -v var\t標準出力に表示するのではなく、出力をシェル変数 VAR に代入しま"
"す\n"
"    \n"
"    FORMAT は次の3種類のオブジェクトを含む文字列です。一つ目は普通の文字で単"
"に\n"
"    標準出力にコピーされます。二つ目はエスケープ文字で変換された後標準出力"
"に\n"
"    コピーされます。三つ目は書式指定文字で、各文字は後に続く引数を表示しま"
"す。\n"
"    \n"
"    printf(1) および printf(3) に記述される標準の書式指定に加えて、printf "
"は\n"
"    次の文字を解釈します。\n"
"    \n"
"      %b\t対応する引数のバックスラッシュエスケープ文字を展開する\n"
"      %q\tシェル入力として引数をクオートする\n"
"      %(fmt)T   FMT を strftime(3) 用の書式文字列として日付と時間の文字列を出"
"力する\n"
"    \n"
"    終了ステータス:\n"
"    無効な引数が与えられるか、書き込み、代入エラーが発生しない限り成功を返し"
"ます。"

#: builtins.c:1942
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \tcompletion attempted on a blank line\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.  The -D option takes\n"
"    precedence over -E.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"引数が Readline によってどのように補完されるかを指定します。\n"
"    \n"
"    各 NAME に対してどのように引数が補完されるかを指定します。オプションが与"
"え\n"
"    られない場合、既存の補完指定が入力として再利用可能な形式で表示されま"
"す。\n"
"    \n"
"    \n"
"    オプション:\n"
"      -p\t既存の補完指定を再利用可能な形式で表示する\n"
"      -r\t補完指定 NAME を削除します。NAME が与えられない場合、全ての\n"
"    \t補完指定を削除する\n"
"      -D\t補完指定が定義されていない時のコマンドに対するデフォルトの\n"
"    \t補完と動作を適用する\n"
"      -E\t\"空\" コマンドに対する補完 (空行に対する補完の試み) と動作\n"
"    \tを適用する\n"
"    \n"
"    補完が試みられた時、上記オプションのうち大文字のオプションの動作が\n"
"    行われます。-D オプションは -E オプションより優先されます。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるかエラーが発生しない限り成功を返します。"

#: builtins.c:1970
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"オプションに基づいた補完候補を表示します。\n"
"    \n"
"    シェル関数の中で補完候補を生成するために使用するように意図されていま"
"す。\n"
"    オプション引数 WORD が与えられた場合、WORD に対して一致した候補が生成\n"
"    されます。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるかエラーが発生しない限り成功を返します。"

#: builtins.c:1985
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"補完オプションを編集または表示します。\n"
"    \n"
"    各 NAME に対して補完オプションを変更します。NAME が与えられない場合、\n"
"    補完が直ちに実行されます。もし OPTION が与えられない場合、各 NAME \n"
"    または現在の補完に対する補完オプションを表示します。\n"
"    \n"
"    オプション:\n"
"    \t-o option\t各 NAME に対して補完オプション OPTION を設定する\n"
"    \t-D\t\t\"デフォルト\" コマンド補完オプションを変更する\n"
"    \t-E\t\t\"空\" コマンド補完オプションを変更する\n"
"    \n"
"    `-o' の代わりに `+o' を使用すると指定したオプションをオフにします。\n"
"    \n"
"    引数:\n"
"    \n"
"    各 NAME は `complete' 組み込み関数を使って事前に定義された補完指定をコ"
"マ\n"
"    ンドを指し示さなければなりません。NAME が与えられない場合、compopt は\n"
"    補完をこれから生成する関数から呼び出されなければいけません。そして\n"
"    補完をこれから生成する関数に対するオプションが変更されます。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられるか、 NAME が補完指定として定義されていない場"
"合\n"
"    を除き、成功を返します。"

#: builtins.c:2015
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied.\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0.\n"
"      -s count \tDiscard the first COUNT lines read.\n"
"      -t\t\tRemove a trailing newline from each line read.\n"
"      -u fd\t\tRead lines from file descriptor FD instead of the standard "
"input.\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
"      -c quantum\tSpecify the number of lines read between each call to "
"CALLBACK.\n"
"    \n"
"    Arguments:\n"
"      ARRAY\t\tArray variable name to use for file data.\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"標準入力から行を読み込みインデックス型配列に代入します。\n"
"    \n"
"    標準入力、-u オプションが与えられた場合はファイル記述子 FD から行を読み込"
"み、\n"
"    インデックス型配列変数 ARRAY に代入します。変数 ARRAY のデフォルトは "
"MAPFILE\n"
"    です。\n"
"    \n"
"    オプション:\n"
"      -n count\t最大 COUNT 行をコピーする。COUNT が 0 の場合、全ての行をコ"
"ピーする\n"
"      -O origin\t配列の開始番号を ORIGIN にする。デフォルトは 0\n"
"      -s count \t最初の COUNT 行の読み込みを破棄する\n"
"      -t\t\t各行を読み込んだ時に最後の改行を削除する\n"
"      -u fd\t\t標準入力ではなくファイル記述子 FD から行を読み込む\n"
"      -C callback\tQUANTUM 行を読み込む毎に CALLBACK を評価する\n"
"      -c quantum\tCALLBACK を何行読み込む毎に実行するかを指定する\n"
"    \n"
"    引数:\n"
"      ARRAY\t\tデータを保存するために使用する配列変数名\n"
"    \n"
"    もし -c が指定されずに -C が与えられた場合、デフォルトの quantum は 5000 "
"です。\n"
"    CALLBACK が評価された時、代入される配列の次要素のインデックスと、要素に代"
"入さ\n"
"    れる行が追加の引数として渡されます。\n"
"    \n"
"    明示的に開始番号が与えられない場合、mapfile は代入前に ARRAY を空にしま"
"す。\n"
"    \n"
"    終了ステータス:\n"
"    無効なオプションが与えられる、配列が読み取り専用、またはインデックス型配"
"列で無い\n"
"    場合を除き成功を返します。"

#: builtins.c:2049
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"ファイルから行を読み込み配列変数に代入します。\n"
"    \n"
"    `mapfile'の別名です。"

#~ msgid "Copyright (C) 2009 Free Software Foundation, Inc.\n"
#~ msgstr "Copyright (C) 2009 Free Software Foundation, Inc.\n"

#~ msgid ""
#~ "License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl."
#~ "html>\n"
#~ msgstr ""
#~ "ライセンス GPLv2+: GNU GPL バージョン 2 またはそれ以降 <http://gnu.org/"
#~ "licenses/gpl.html>\n"

#~ msgid ""
#~ ".  With EXPR, returns\n"
#~ "    "
#~ msgstr ""
#~ "。  EXPR が存在する場合、次を返します \n"
#~ "    "

#~ msgid ""
#~ "; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before "
#~ "the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "。この追加の情報はスタックトレース\n"
#~ "    を提供する時に利用します。\n"
#~ "\n"
#~ "    EXPR の値は現在のフレームに戻るまでに何回フレームが呼び出されているか"
#~ "を\n"
#~ "    意味します。最上位のフレームは 0 です。"
